{% extends "base.html" %}

{% block title %}Sequencer - PAS Agent Swarm{% endblock %}

{% block extra_styles %}
<style>
    #sequencer-container {
        width: 100%;
        height: calc(100vh - 100px);
        background: linear-gradient(135deg, #0f1423 0%, #1a1f3a 100%);
        border-radius: 12px;
        margin-top: 1rem;
        overflow: hidden;
        position: relative;
        display: flex;
        flex-direction: column;
    }

    #sequencer-toolbar {
        background: rgba(30, 39, 71, 0.95);
        border-bottom: 2px solid #4a5578;
        padding: 1rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
    }

    #sequencer-canvas-wrapper {
        flex: 1;
        position: relative;
        overflow-x: auto;  /* Horizontal scroll for timeline */
        overflow-y: scroll; /* ALWAYS show vertical scrollbar */
        background: #0a0e27;
    }

    /* Style the scrollbar */
    #sequencer-canvas-wrapper::-webkit-scrollbar {
        width: 14px;
        height: 14px;
    }

    #sequencer-canvas-wrapper::-webkit-scrollbar-track {
        background: rgba(30, 39, 71, 0.5);
    }

    #sequencer-canvas-wrapper::-webkit-scrollbar-thumb {
        background: rgba(59, 130, 246, 0.6);
        border-radius: 7px;
        border: 2px solid rgba(30, 39, 71, 0.5);
    }

    #sequencer-canvas-wrapper::-webkit-scrollbar-thumb:hover {
        background: rgba(59, 130, 246, 0.8);
    }

    #sequencer-canvas {
        display: block;
        cursor: crosshair;
    }

    .playhead {
        position: absolute;
        top: 0;
        width: 2px;
        height: 100%;
        background: #ef4444;
        pointer-events: none;
        z-index: 100;
        box-shadow: 0 0 8px rgba(239, 68, 68, 0.8);
    }

    .playhead::before {
        content: 'NOW';
        position: absolute;
        top: 65px;
        left: 6px;
        font-size: 14px;
        font-weight: bold;
        color: #ef4444;
        text-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
        white-space: nowrap;
        pointer-events: none;
    }

    .playhead-handle {
        position: absolute;
        top: -8px;
        left: -8px;
        width: 16px;
        height: 16px;
        background: #ef4444;
        border: 2px solid white;
        border-radius: 50%;
        cursor: grab;
        pointer-events: all;
        z-index: 101;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
    }

    .playhead-handle:hover {
        transform: scale(1.2);
        background: #dc2626;
    }

    .playhead-handle:active {
        cursor: grabbing;
    }

    .toolbar-group {
        display: flex;
        align-items: center;
        gap: 0.75rem;
    }

    .toolbar-label {
        color: #9ca3af;
        font-size: 0.875rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }

    .project-selector {
        padding: 0.5rem 1rem;
        background: rgba(30, 39, 71, 0.95);
        border: 1px solid #4a5578;
        border-radius: 6px;
        color: #e0e0e0;
        font-size: 0.875rem;
        cursor: pointer;
        transition: all 0.2s;
        min-width: 200px;
        max-width: 300px;
    }

    .project-selector:hover {
        background: rgba(59, 130, 246, 0.2);
        border-color: #3b82f6;
    }

    .project-selector:focus {
        outline: none;
        border-color: #3b82f6;
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
    }

    .project-selector option {
        background: #1a1f3a;
        color: #e0e0e0;
        padding: 0.5rem;
    }

    .toolbar-button {
        padding: 0.5rem 1rem;
        background: rgba(59, 130, 246, 0.8);
        border: 1px solid #3b82f6;
        border-radius: 6px;
        color: white;
        cursor: pointer;
        font-size: 0.875rem;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .toolbar-button:hover {
        background: rgba(59, 130, 246, 1);
        transform: translateY(-1px);
    }

    .toolbar-button:active {
        transform: translateY(0);
    }

    .toolbar-button.active {
        background: rgba(16, 185, 129, 0.8);
        border-color: #10b981;
    }

    .toolbar-button.active:hover {
        background: rgba(16, 185, 129, 1);
    }

    .zoom-control {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        color: #e0e0e0;
    }

    .zoom-button {
        padding: 0.25rem 0.5rem;
        background: rgba(59, 130, 246, 0.6);
        border: 1px solid #3b82f6;
        border-radius: 4px;
        color: white;
        cursor: pointer;
        font-size: 1rem;
        font-weight: 600;
        transition: all 0.2s;
    }

    .zoom-button:hover {
        background: rgba(59, 130, 246, 0.8);
    }

    .time-display {
        color: #e0e0e0;
        font-size: 1rem;
        font-family: 'Courier New', monospace;
        font-weight: 600;
        padding: 0.5rem 1rem;
        background: rgba(30, 39, 71, 0.8);
        border-radius: 6px;
    }

    .legend {
        position: absolute;
        bottom: 1rem;
        right: 1rem;
        background: rgba(30, 39, 71, 0.65);
        border: 1px solid rgba(74, 85, 120, 0.5);
        border-radius: 8px;
        padding: 1rem;
        color: #e0e0e0;
        font-size: 0.875rem;
        z-index: 10;
        max-width: 250px;
    }

    .legend-title {
        font-weight: 600;
        margin-bottom: 0.75rem;
        color: #fff;
        border-bottom: 1px solid #4a5578;
        padding-bottom: 0.5rem;
    }

    .legend-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin: 0.5rem 0;
    }

    .legend-color {
        width: 20px;
        height: 12px;
        border-radius: 3px;
        border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .tooltip {
        position: absolute;
        padding: 0.75rem 1rem;
        background: rgba(30, 39, 71, 0.95);
        border: 1px solid #4a5578;
        border-radius: 8px;
        color: #e0e0e0;
        font-size: 0.875rem;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s;
        z-index: 1000;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        max-width: 300px;
    }

    .tooltip.visible {
        opacity: 1;
    }

    .tooltip-title {
        font-weight: 600;
        color: #fff;
        margin-bottom: 0.5rem;
    }

    .tooltip-row {
        display: flex;
        justify-content: space-between;
        gap: 1rem;
        margin: 0.25rem 0;
    }

    .tooltip-label {
        color: #9ca3af;
    }

    .tooltip-value {
        color: #e0e0e0;
        font-weight: 500;
    }

    /* Playback Speed Control */
    .playback-speed-container {
        background: rgba(30, 39, 71, 0.95);
        border-top: 2px solid #4a5578;
        padding: 1rem;
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 1rem;
    }

    .speed-slider-group {
        display: flex;
        align-items: center;
        gap: 1rem;
        max-width: 600px;
        width: 100%;
    }

    .speed-label {
        color: #9ca3af;
        font-size: 0.875rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        white-space: nowrap;
    }

    .speed-slider {
        flex: 1;
        height: 6px;
        border-radius: 3px;
        background: rgba(74, 85, 120, 0.5);
        outline: none;
        -webkit-appearance: none;
        appearance: none;
    }

    .speed-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #3b82f6;
        cursor: pointer;
        box-shadow: 0 0 8px rgba(59, 130, 246, 0.6);
    }

    .speed-slider::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #3b82f6;
        cursor: pointer;
        border: none;
        box-shadow: 0 0 8px rgba(59, 130, 246, 0.6);
    }

    .speed-slider:hover::-webkit-slider-thumb {
        background: #2563eb;
    }

    .speed-slider:hover::-moz-range-thumb {
        background: #2563eb;
    }

    .speed-value {
        color: #e0e0e0;
        font-size: 1rem;
        font-family: 'Courier New', monospace;
        font-weight: 600;
        min-width: 60px;
        text-align: center;
        padding: 0.5rem 1rem;
        background: rgba(30, 39, 71, 0.8);
        border-radius: 6px;
    }

    /* üÜï Prime Directive Completion Banner Animations */
    @keyframes slideDown {
        from {
            transform: translate(-50%, -150%);
            opacity: 0;
        }
        to {
            transform: translate(-50%, -50%);
            opacity: 1;
        }
    }

    @keyframes slideUp {
        from {
            transform: translate(-50%, -50%);
            opacity: 1;
        }
        to {
            transform: translate(-50%, -150%);
            opacity: 0;
        }
    }

    #end-of-project-banner button:hover {
        transform: scale(1.05);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3) !important;
    }
</style>
{% endblock %}

{% block content %}
<div class="container" style="max-width: 100%; padding: 1rem 2rem;">
    <div id="sequencer-container">
        <!-- Toolbar -->
        <div id="sequencer-toolbar">
            <!-- Prime Directive Selector (leftmost) -->
            <div class="toolbar-group">
                <span class="toolbar-label">Prime Directive</span>
                <select id="project-selector" class="project-selector" onchange="changeProject()" title="Select a prime directive (top-level human request to PAS Root)">
                    <option value="">Loading prime directives...</option>
                </select>
            </div>

            <div class="toolbar-group">
                <span class="toolbar-label">Playback</span>
                <button id="play-pause-btn" class="toolbar-button" onclick="togglePlayPause()">
                    <span id="play-icon">‚ñ∂Ô∏è</span> <span id="play-text">Play</span>
                </button>
                <button class="toolbar-button" onclick="resetPlayhead()">‚èπÔ∏è Stop</button>
            </div>

            <!-- Playback Speed moved to bottom for wider slider -->

            <div class="toolbar-group">
                <span class="toolbar-label">Sound</span>
                <select id="sound-mode" class="toolbar-button" style="padding: 0.5rem;" onchange="changeSoundMode()">
                    <option value="none" selected>None</option>
                    <option value="voice">Voice</option>
                    <option value="music">Music Note</option>
                    <option value="random">Random Sounds</option>
                    <option value="geiger">Geiger Counter</option>
                </select>
            </div>

            <!-- Zoom moved to bottom as slider -->

            <div class="toolbar-group">
                <span class="toolbar-label">Time Range</span>
                <select id="time-range" class="toolbar-button" style="padding: 0.5rem;" onchange="changeTimeRange()">
                    <option value="300">Last 5 min</option>
                    <option value="900">Last 15 min</option>
                    <option value="1800">Last 30 min</option>
                    <option value="3600" selected>Last 1 hour</option>
                    <option value="7200">Last 2 hours</option>
                    <option value="14400">Last 4 hours</option>
                </select>
            </div>

            <div class="toolbar-group">
                <div class="time-display" id="current-time">00:00:00</div>
            </div>

            <div class="toolbar-group">
                <span class="toolbar-label">ARROWS</span>
                <select id="arrow-display-mode" class="project-selector" style="min-width: 180px;" onchange="changeArrowMode(this.value)">
                    <option value="all" selected>Show All Arrows</option>
                    <option value="start-only">Start Only (Blue ‚Üì)</option>
                    <option value="end-only">End Only (Green ‚Üë)</option>
                    <option value="start-end">Start & End</option>
                    <option value="none">No Arrows</option>
                </select>
            </div>

            <div class="toolbar-group">
                <span class="toolbar-label">DEDUP</span>
                <select id="dedup-mode-select" class="project-selector" style="min-width: 150px;" onchange="changeDedupMode(this.value)">
                    <option value="none">Raw (No Dedup)</option>
                    <option value="smart" selected>Smart (Prog Only)</option>
                    <option value="full">Full Dedup</option>
                </select>
            </div>

            <div class="toolbar-group">
                <button class="toolbar-button" onclick="fitAll()">üìê Fit All</button>
                <button class="toolbar-button" onclick="refreshSequencer()">üîÑ Refresh</button>
            </div>
        </div>

        <!-- Canvas Wrapper -->
        <div id="sequencer-canvas-wrapper">
            <canvas id="sequencer-canvas"></canvas>
            <div id="playhead" class="playhead" style="left: 0px;">
                <div id="playhead-handle" class="playhead-handle"></div>
            </div>
        </div>

        <!-- Bottom Controls: Playback Speed + Zoom (Wide Sliders) -->
        <div class="playback-speed-container" style="gap: 2rem;">
            <div class="speed-slider-group">
                <span class="speed-label">Playback Speed</span>
                <input type="range" id="playback-speed-bottom" class="speed-slider"
                       min="0" max="100" step="1" value="50"
                       oninput="updatePlaybackSpeedFromSlider(this.value, 'bottom')">
                <span id="speed-value-bottom" class="speed-value">1.0x</span>
            </div>
            <div class="speed-slider-group">
                <span class="speed-label">Horiz Zoom</span>
                <input type="range" id="zoom-slider" class="speed-slider"
                       min="0" max="100" step="1" value="50"
                       oninput="updateZoomFromSlider(this.value)">
                <span id="zoom-level" class="speed-value">100%</span>
            </div>
            <div class="speed-slider-group">
                <span class="speed-label">Task Zoom</span>
                <input type="range" id="vertical-zoom-slider" class="speed-slider"
                       min="0" max="100" step="1" value="50"
                       oninput="updateVerticalZoomFromSlider(this.value)">
                <span id="vertical-zoom-value" class="speed-value">100%</span>
            </div>
        </div>

        <!-- Legend -->
        <div class="legend">
            <div class="legend-title">Status Colors</div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #60a5fa;"></div>
                <span>Running (0-25%)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #fbbf24;"></div>
                <span>Running (25-75%)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #34d399;"></div>
                <span>Running (75-100%)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #fb923c;"></div>
                <span>Blocked/Waiting</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #c084fc;"></div>
                <span>Awaiting Approval</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #f87171;"></div>
                <span>Stuck/Error</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #9ca3af;"></div>
                <span>Done/Idle</span>
            </div>
        </div>
    </div>

    <div id="tooltip" class="tooltip"></div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
    // Global variables
    let canvas, ctx;
    let isPlaying = false;
    let playheadPosition = 0;
    let projectComplete = false;  // Track if Prime Directive is complete
    let zoomLevel = parseFloat(localStorage.getItem('sequencer_zoomLevel')) || 1.0;
    let timeRangeSeconds = parseInt(localStorage.getItem('sequencer_timeRange')) || 300; // Default: 5 min
    let playbackSpeed = 1.0; // Playback speed multiplier (0.1x to 5.0x)
    let soundMode = 'none'; // none, voice, music, random
    let verticalZoom = parseFloat(localStorage.getItem('sequencer_verticalZoom')) || 1.0;
    let agents = [];
    let tasks = [];
    let autoRefreshTimer = null;
    let timelineOffset = 0; // Pan offset in seconds (for timeline dragging)
    let verticalOffset = 0; // NEW: Vertical pan offset in pixels (for scrolling up/down)
    let projectName = 'Project Timeline'; // Project/task name for header
    let projectTaskId = null; // Current task ID

    // Console flood protection
    let frameCounter = 0;
    const LOG_EVERY_N_FRAMES = 100; // Only log every 100th frame (every 10 seconds at 100ms/frame)

    // Initialize sequencer start time (prevents undefined errors)
    window._sequencerStartTime = 0;

    // Layout constants
    const HEADER_HEIGHT = 60; // Height for project header bar
    const ROW_HEIGHT = 40;
    const ROW_PADDING = 5;
    const AGENT_LABEL_WIDTH = 150;
    const PIXELS_PER_SECOND = 2; // Base: 2 pixels = 1 second

    // Color mapping (VIBRANT colors for better visibility)
    const statusColors = {
        'running_0_25': '#60a5fa',     // Bright Blue (lighter)
        'running_25_75': '#fbbf24',    // Bright Yellow
        'running_75_100': '#34d399',   // Bright Green (lighter)
        'blocked': '#fb923c',          // Bright Orange
        'waiting': '#fb923c',          // Bright Orange
        'awaiting_approval': '#c084fc', // Bright Purple (lighter)
        'stuck': '#f87171',            // Bright Red (lighter)
        'error': '#f87171',            // Bright Red (lighter)
        'done': '#9ca3af',             // Light Gray (more visible)
        'idle': '#9ca3af'              // Light Gray (more visible)
    };

    function initializeSequencer() {
        canvas = document.getElementById('sequencer-canvas');
        ctx = canvas.getContext('2d');

        // Set canvas size
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Mouse events for interactions
        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('mousemove', handleCanvasHover);
        canvas.addEventListener('mouseleave', hideTooltip);

        // Mouse wheel for zoom control
        canvas.addEventListener('wheel', handleMouseWheel, { passive: false });

        // Draggable playhead
        initializePlayheadDrag();
    }

    let isDraggingPlayhead = false;
    let isDraggingTimeline = false;
    let dragStartX = 0;
    let dragStartOffset = 0;

    /**
     * Handle mouse wheel events for zoom/scroll control
     * - Shift+Wheel: Vertical scroll (pan up/down)
     * - Ctrl+Wheel: Vertical zoom (row height)
     * - Wheel alone: Horizontal zoom (time axis)
     */
    function handleMouseWheel(event) {
        event.preventDefault(); // Prevent page scroll

        const delta = -Math.sign(event.deltaY); // Invert: scroll up = zoom in, scroll down = zoom out
        const zoomFactor = 1.1; // 10% change per scroll step

        if (event.shiftKey) {
            // SHIFT + WHEEL: Vertical pan (scroll up/down through agents)
            const scrollAmount = event.deltaY; // Use raw delta for smooth scrolling
            verticalOffset = Math.max(0, verticalOffset + scrollAmount);

            // Clamp to prevent scrolling beyond bottom
            const totalHeight = agents.length * ROW_HEIGHT * verticalZoom;
            const maxOffset = Math.max(0, totalHeight - canvas.height + HEADER_HEIGHT);
            verticalOffset = Math.min(verticalOffset, maxOffset);

            drawSequencer();
        } else if (event.ctrlKey || event.metaKey) {
            // CTRL/CMD + WHEEL: Vertical zoom (row height)
            let newVerticalZoom;
            if (delta > 0) {
                newVerticalZoom = Math.min(verticalZoom * zoomFactor, 3.0); // Max 3x row height
            } else {
                newVerticalZoom = Math.max(verticalZoom / zoomFactor, 0.3); // Min 0.3x row height
            }
            verticalZoom = newVerticalZoom;
            localStorage.setItem('sequencer_verticalZoom', verticalZoom); // Persist vertical zoom
            drawSequencer();
        } else {
            // WHEEL ALONE: Horizontal zoom (time axis)
            let newZoom;
            if (delta > 0) {
                newZoom = Math.min(zoomLevel * zoomFactor, 20.0);
            } else {
                newZoom = Math.max(zoomLevel / zoomFactor, 0.1);
            }
            updateZoom(newZoom);
        }
    }

    function initializePlayheadDrag() {
        const playheadHandle = document.getElementById('playhead-handle');
        const canvasWrapper = document.getElementById('sequencer-canvas-wrapper');

        playheadHandle.addEventListener('mousedown', (e) => {
            isDraggingPlayhead = true;
            e.preventDefault();
            e.stopPropagation();
        });

        // Sync scrollbar with vertical offset
        canvasWrapper.addEventListener('scroll', (e) => {
            // Update verticalOffset from scrollbar position
            verticalOffset = e.target.scrollTop;
            drawSequencer();
        });

        // Canvas dragging for timeline panning
        canvas.addEventListener('mousedown', (e) => {
            // Don't start timeline drag if clicking on playhead
            if (isDraggingPlayhead) return;

            isDraggingTimeline = true;
            dragStartX = e.clientX;
            dragStartOffset = timelineOffset;
            canvas.style.cursor = 'grabbing';
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (isDraggingPlayhead) {
                const wrapperRect = canvasWrapper.getBoundingClientRect();
                const x = e.clientX - wrapperRect.left;

                // Calculate playhead position (simple pixel-to-time conversion, no timeline offset)
                const clickedTime = (x - AGENT_LABEL_WIDTH) / (PIXELS_PER_SECOND * zoomLevel);
                playheadPosition = Math.max(0, clickedTime);

                updatePlayhead();
                updateCurrentTime();
            } else if (isDraggingTimeline) {
                const deltaX = dragStartX - e.clientX;
                const deltaTime = deltaX / (PIXELS_PER_SECOND * zoomLevel);
                timelineOffset = Math.max(0, dragStartOffset + deltaTime);

                // CRITICAL: Keep playheadPosition synchronized with timelineOffset
                // This ensures sounds/flashes trigger at the correct visual position
                playheadPosition = timelineOffset;

                drawSequencer();
                updatePlayhead();
            }
        });

        document.addEventListener('mouseup', () => {
            isDraggingPlayhead = false;
            if (isDraggingTimeline) {
                isDraggingTimeline = false;
                canvas.style.cursor = 'grab';
            }
        });

        // Set initial cursor
        canvas.style.cursor = 'grab';
    }

    /**
     * Allocate lanes for overlapping tasks
     * Creates sub-rows (lanes) when an agent has overlapping tasks
     * Updates agents array with lane information
     */
    function allocateLanes() {
        // Group tasks by agent
        const tasksByAgent = {};
        tasks.forEach(task => {
            if (!tasksByAgent[task.agent_id]) {
                tasksByAgent[task.agent_id] = [];
            }
            tasksByAgent[task.agent_id].push(task);
        });

        // For each agent, allocate lanes for overlapping tasks
        const expandedAgents = [];
        agents.forEach(agent => {
            const agentTasks = tasksByAgent[agent.service_id] || [];

            // Sort tasks by start time
            agentTasks.sort((a, b) => a.start_time - b.start_time);

            // Allocate lanes using greedy algorithm with delegation-time-based concurrency detection
            const lanes = [];
            const DELEGATION_WINDOW = 15; // Seconds - tasks delegated within this window are considered concurrent

            agentTasks.forEach(task => {
                const taskStart = task.start_time;
                const taskEnd = task.end_time || (taskStart + 30); // Estimate 30s for running tasks

                // Find first available lane (no overlapping tasks OR recent delegation)
                let assignedLane = -1;
                for (let i = 0; i < lanes.length; i++) {
                    const lane = lanes[i];
                    const lastTaskInLane = lane[lane.length - 1];
                    const lastTaskEnd = lastTaskInLane.end_time || (lastTaskInLane.start_time + 30);
                    const lastTaskDelegationTime = lastTaskInLane.start_time;

                    // Check if this task can fit in this lane
                    // Two conditions must BOTH be true:
                    // 1. No temporal overlap: this task starts after previous task ends
                    // 2. Not concurrently delegated: tasks were not delegated within same time window
                    const noTemporalOverlap = (taskStart >= lastTaskEnd);
                    const notConcurrentlyDelegated = (taskStart - lastTaskDelegationTime) >= DELEGATION_WINDOW;

                    if (noTemporalOverlap && notConcurrentlyDelegated) {
                        assignedLane = i;
                        break;
                    }
                }

                // If no available lane, create a new one
                if (assignedLane === -1) {
                    assignedLane = lanes.length;
                    lanes.push([]);
                }

                // Assign task to lane
                task._lane = assignedLane;
                lanes[assignedLane].push(task);
            });

            // Create agent rows (one per lane)
            const numLanes = lanes.length;
            if (numLanes === 0) {
                // Agent has no tasks, still show one row
                expandedAgents.push({
                    ...agent,
                    _laneCount: 1,
                    _laneIndex: 0,
                    _isParent: false
                });
            } else if (numLanes === 1) {
                // Agent has only one lane (no overlaps), show single row
                expandedAgents.push({
                    ...agent,
                    _laneCount: 1,
                    _laneIndex: 0,
                    _isParent: false
                });
            } else {
                // Agent has multiple lanes (overlapping tasks), create sub-rows
                for (let i = 0; i < numLanes; i++) {
                    expandedAgents.push({
                        ...agent,
                        name: i === 0 ? agent.name : `  ‚îî‚îÄ Lane ${i + 1}`,
                        _laneCount: numLanes,
                        _laneIndex: i,
                        _isParent: i === 0,
                        _parentAgent: agent.service_id
                    });
                }
            }
        });

        // Replace agents array with expanded version
        agents = expandedAgents;

        // Log lane allocation summary
        const agentsWithMultipleLanes = expandedAgents.filter(a => a._isParent && a._laneCount > 1);
        const totalSubLanes = expandedAgents.filter(a => a._laneIndex > 0).length;

        console.log(`[LANES] Allocated ${agents.length} rows (${totalSubLanes} sub-lanes)`);
        // DEBUG: Removed excessive lane allocation logging
        // Lane allocation info moved to summary only if needed
    }

    function resizeCanvas() {
        const wrapper = document.getElementById('sequencer-canvas-wrapper');

        // Calculate minimum width based on time range
        const pixelsPerSecond = PIXELS_PER_SECOND * zoomLevel;
        const timelineWidth = AGENT_LABEL_WIDTH + (timeRangeSeconds * pixelsPerSecond);
        const minWidth = Math.max(timelineWidth, 2000);

        // Calculate total height needed for all agent rows (with vertical zoom applied)
        const rowHeight = ROW_HEIGHT * verticalZoom;
        const totalContentHeight = HEADER_HEIGHT + (agents.length * rowHeight) + 100;

        // Set canvas dimensions
        // Width: Allow horizontal scrolling for wide timelines
        canvas.width = Math.max(wrapper.clientWidth, minWidth);

        // Height: ALWAYS use content height (not viewport height) to enable scrolling
        // This ensures the scrollbar appears when content exceeds viewport
        canvas.height = totalContentHeight;

        // Reset verticalOffset if scrolling is needed
        const maxOffset = Math.max(0, totalContentHeight - wrapper.clientHeight);
        if (verticalOffset > maxOffset) {
            verticalOffset = maxOffset;
        }

        drawSequencer();
    }

    async function fetchSequencerData() {
        try {
            // Check if a task is selected from URL params
            const urlParams = new URLSearchParams(window.location.search);
            let taskId = urlParams.get('task_id');
            let isCurrentTask = false;

            // If no task_id provided, try to get current or last task
            if (!taskId) {
                try {
                    // First try to get current running task
                    const currentResp = await fetch('/api/current-task');
                    if (currentResp.ok) {
                        const currentData = await currentResp.json();
                        if (currentData.task_id) {
                            taskId = currentData.task_id;
                            isCurrentTask = true;
                            console.log('Using current running task:', taskId);
                        }
                    }

                    // If no current task, get the most recent task from action logs
                    if (!taskId) {
                        const tasksResp = await fetch('/api/actions/tasks?limit=1');
                        if (tasksResp.ok) {
                            const tasksData = await tasksResp.json();
                            if (tasksData.items && tasksData.items.length > 0) {
                                taskId = tasksData.items[0].task_id;
                                console.log('Using last task from history:', taskId);
                            }
                        }
                    }
                } catch (e) {
                    console.warn('Could not fetch current/last task:', e);
                }
            }

            let url = '/api/sequencer';
            if (taskId) {
                url = `/api/sequencer?source=actions&task_id=${taskId}`;
                // Update URL without reloading page
                if (!urlParams.get('task_id')) {
                    window.history.replaceState({}, '', `?task_id=${taskId}`);
                }
            }

            const response = await fetch(url);
            const data = await response.json();
            console.log('Fetched sequencer data:', data);
            agents = data.agents || [];

            // Use deduplicated tasks if mode is set, otherwise use raw tasks
            const dedupMode = window.sequencerSettings?.dedupMode || 'smart';
            if (dedupMode === 'none') {
                tasks = data.tasks || [];  // Raw tasks (Option 3: Transparency)
            } else {
                tasks = data.tasks_deduplicated || data.tasks || [];  // Deduplicated tasks
            }
            console.log(`[DEDUP] Using mode="${dedupMode}", task count=${tasks.length}`);

            // üÜï Check for Prime Directive completion signal
            const completionTask = tasks.find(t =>
                t.action_type === 'directive_complete' &&
                t.from_agent === 'PAS_ROOT'
            );

            if (completionTask && !projectComplete) {
                handleDirectiveComplete(completionTask);
            }

            // Detect real-time task changes and trigger sounds (for Start Demo)
            detectRealtimeTaskChanges(data.tasks || []);

            // Allocate lanes for overlapping tasks (NEW!)
            allocateLanes();

            // IMPORTANT: Don't clear lastTriggeredTaskStarts during refresh if playing
            // This prevents duplicate sounds when data refreshes mid-playback
            if (!isPlaying) {
                console.log('[Refresh] Not playing - safe to clear triggered tasks on next playback');
            } else {
                console.log('[Refresh] Playing - preserving triggered tasks to prevent duplicate sounds');
            }

            // Set project name from data (or use task_id as fallback)
            projectTaskId = taskId;
            projectName = data.project_name || data.task_name || (taskId ? `Task ${taskId}` : 'Project Timeline');

            // Auto-play if this is a current running task at 1x speed
            // Otherwise start at beginning (playhead at 0, stopped)
            if (isCurrentTask && !isPlaying) {
                console.log('Auto-playing current task at 1x speed');
                // Set playback speed to 1x
                updatePlaybackSpeed(1.0, 'auto');
                // Start playing after a short delay
                setTimeout(togglePlayPause, 500);
            } else if (!isCurrentTask) {
                // CRITICAL: Preserve playback position during refreshes
                // Only reset if we're at the very beginning and not playing
                if (playheadPosition === 0 && !isPlaying) {
                    console.log('Historical task - starting at beginning (stopped)');
                } else {
                    console.log('Historical task - preserving playback state during refresh');
                }
                // Don't reset playheadPosition during refresh!
            }

            drawSequencer();
            
            // üÜï Auto-fit zoom to screen on initial data load (after canvas resize)
            if (!window._sequencerInitialZoomFit) {
                console.log('üéØ [AUTO-FIT] Scheduling initial zoom to fit screen after canvas resize');
                // Wait for next frame to ensure canvas is properly resized
                requestAnimationFrame(() => {
                    console.log('üéØ [AUTO-FIT] Applying initial zoom to fit screen');
                    resizeCanvas(); // Ensure canvas is properly sized first
                    fitAll();
                    window._sequencerInitialZoomFit = true;
                });
            }
        } catch (error) {
            console.error('Error fetching sequencer data:', error);
        }
    }

    function drawSequencer() {
        if (!ctx) return;

        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw project header bar (top)
        drawProjectHeader();

        // Draw timeline grid
        drawTimelineGrid();

        // Draw agent rows
        drawAgentRows();

        // Draw task blocks
        drawTaskBlocks();

        // Draw arrows (parent‚Üíchild, child‚Üíparent)
        // Always call drawTaskArrows - it will check individual arrow type settings
        drawTaskArrows();

        // NOTE: Red playhead (HTML element) is positioned at left edge (AGENT_LABEL_WIDTH)
        // Sounds trigger when tasks cross the playhead during timeline scrolling
    }

    function drawProjectHeader() {
        // Calculate project duration
        let earliestTime = Infinity;
        let latestTime = -Infinity;
        let hasRunningTasks = false;

        tasks.forEach(task => {
            if (task.start_time < earliestTime) earliestTime = task.start_time;

            // Check if task is still running (no end_time)
            if (!task.end_time && ['running', 'blocked', 'waiting'].includes(task.status)) {
                hasRunningTasks = true;
            }

            const endTime = task.end_time || (Date.now() / 1000); // Use current time for running tasks
            if (endTime > latestTime) latestTime = endTime;
        });

        // If no tasks, use current time as reference
        if (earliestTime === Infinity) {
            earliestTime = Date.now() / 1000;
            latestTime = earliestTime + 60; // Default 1 minute span
        }

        const startTime = earliestTime;
        const duration = latestTime - earliestTime;
        const pixelsPerSecond = PIXELS_PER_SECOND * zoomLevel;

        // Calculate header bar position and width
        const x = AGENT_LABEL_WIDTH + ((0 - timelineOffset) * pixelsPerSecond); // Start at timeline 0
        const width = duration * pixelsPerSecond;

        // Draw header background (gradient for visual appeal)
        const gradient = ctx.createLinearGradient(x, 0, x + width, 0);
        gradient.addColorStop(0, '#3b82f6');   // Blue
        gradient.addColorStop(0.5, '#8b5cf6'); // Purple
        gradient.addColorStop(1, '#ec4899');   // Pink

        ctx.fillStyle = gradient;
        ctx.fillRect(x, 0, width, HEADER_HEIGHT);

        // Draw border
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, 0, width, HEADER_HEIGHT);

        // Draw project name text (centered in header)
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 20px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // Truncate text if needed
        const maxTextWidth = width - 20;
        let displayName = projectName;
        let textWidth = ctx.measureText(displayName).width;

        if (textWidth > maxTextWidth) {
            while (ctx.measureText(displayName + '...').width > maxTextWidth && displayName.length > 0) {
                displayName = displayName.slice(0, -1);
            }
            displayName += '...';
        }

        // Draw text in center of header bar
        ctx.fillText(displayName, x + width / 2, HEADER_HEIGHT / 2);

        // Draw duration label (bottom right of header)
        const durationText = formatDuration(duration);
        ctx.font = 'bold 12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
        ctx.textAlign = 'right';
        ctx.fillText(`Duration: ${durationText}`, x + width - 10, HEADER_HEIGHT - 10);

        // Reset text align
        ctx.textAlign = 'left';

        // Store startTime globally for use by other draw functions
        window._sequencerStartTime = startTime;
    }

    function drawTimelineGrid() {
        // FIX: Show timeline from task start (earliest action) to present
        // This makes the timeline show relative time from task beginning (t=0 at left edge)
        const pixelsPerSecond = PIXELS_PER_SECOND * zoomLevel;

        // Find earliest task start time to use as timeline origin (t=0)
        let earliestTime = Infinity;
        let latestTime = -Infinity;
        tasks.forEach(task => {
            if (task.start_time < earliestTime) earliestTime = task.start_time;
            // FIX: Don't use Date.now() for old tasks - estimate 30s for running tasks
            const hasRunningStatus = ['running', 'blocked', 'waiting'].includes(task.status);
            const endTime = task.end_time || (hasRunningStatus ? (task.start_time + 30) : (task.start_time + 30));
            if (endTime > latestTime) latestTime = endTime;
        });

        // If no tasks, use current time as reference
        if (earliestTime === Infinity) {
            earliestTime = Date.now() / 1000;
            latestTime = earliestTime + timeRangeSeconds;
        }

        const startTime = earliestTime;  // Left edge of timeline
        const actualDuration = latestTime - earliestTime;
        const displayDuration = Math.max(actualDuration, 60);  // At least 1 minute visible

        // Draw vertical grid lines (every 5 minutes)
        ctx.strokeStyle = 'rgba(74, 85, 120, 0.3)';
        ctx.lineWidth = 1;

        const interval = 300; // 5 minutes in seconds
        const maxTime = Math.max(displayDuration, timeRangeSeconds) + timelineOffset;

        // Start drawing from timelineOffset (accounting for pan)
        const startT = Math.floor(timelineOffset / interval) * interval;

        for (let t = startT; t <= maxTime; t += interval) {
            const x = AGENT_LABEL_WIDTH + ((t - timelineOffset) * pixelsPerSecond);

            // Only draw if visible on canvas
            if (x >= AGENT_LABEL_WIDTH && x <= canvas.width) {
                ctx.beginPath();
                ctx.moveTo(x, HEADER_HEIGHT); // Start below header
                ctx.lineTo(x, canvas.height);
                ctx.stroke();

                // Time label (show relative time from task start)
                const minutesFromStart = Math.floor(t / 60);
                const secondsRemainder = Math.floor(t % 60);
                const timeStr = t === 0 ? '0:00' :
                               `${minutesFromStart}:${secondsRemainder.toString().padStart(2, '0')}`;

                ctx.fillStyle = '#9ca3af';
                ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.fillText(timeStr, x + 5, HEADER_HEIGHT + 15); // Below header
            }
        }

        // Store startTime globally for use by other draw functions
        window._sequencerStartTime = startTime;
    }

    function drawAgentRows() {
        ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';

        agents.forEach((agent, index) => {
            const rowHeight = ROW_HEIGHT * verticalZoom; // Apply vertical zoom
            const y = HEADER_HEIGHT + (index * rowHeight) - verticalOffset; // Apply vertical offset

            // Skip if row is not visible on screen
            if (y + rowHeight < HEADER_HEIGHT || y > canvas.height) return;

            // Determine if this is a sub-lane row
            const isSubLane = agent._laneIndex > 0;
            const isParentWithLanes = agent._isParent && agent._laneCount > 1;

            // Row background (different styling for sub-lanes)
            if (isSubLane) {
                // Sub-lane: slightly darker background
                ctx.fillStyle = 'rgba(20, 25, 50, 0.5)';
            } else if (isParentWithLanes) {
                // Parent with lanes: highlighted
                ctx.fillStyle = index % 2 === 0 ? 'rgba(40, 50, 90, 0.4)' : 'rgba(40, 50, 90, 0.6)';
            } else {
                // Normal row: alternating
                ctx.fillStyle = index % 2 === 0 ? 'rgba(30, 39, 71, 0.3)' : 'rgba(30, 39, 71, 0.5)';
            }
            ctx.fillRect(0, y, canvas.width, rowHeight);

            // Agent label with lane count indicator
            if (isParentWithLanes) {
                // Parent agent with lanes: show lane count
                ctx.fillStyle = '#60a5fa'; // Blue for parent
                ctx.font = 'bold 12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.fillText(`${agent.name} (${agent._laneCount} lanes)`, 10, y + rowHeight / 2 + 5);
                ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            } else if (isSubLane) {
                // Sub-lane: indented with tree connector
                ctx.fillStyle = '#9ca3af'; // Grey for sub-lanes
                ctx.fillText(agent.name, 10, y + rowHeight / 2 + 5);
            } else {
                // Normal agent
                ctx.fillStyle = '#e0e0e0';
                ctx.fillText(agent.name, 10, y + rowHeight / 2 + 5);
            }

            // Horizontal separator (thicker for parent lanes)
            ctx.strokeStyle = isParentWithLanes ? 'rgba(96, 165, 250, 0.5)' : 'rgba(74, 85, 120, 0.5)';
            ctx.lineWidth = isParentWithLanes ? 2 : 1;
            ctx.beginPath();
            ctx.moveTo(0, y + rowHeight);
            ctx.lineTo(canvas.width, y + rowHeight);
            ctx.stroke();
        });
    }

    function drawTaskBlocks() {
        const now = Date.now() / 1000;
        // FIX: Use timeline start time from drawTimelineGrid()
        const startTime = window._sequencerStartTime || now;
        const pixelsPerSecond = PIXELS_PER_SECOND * zoomLevel;

        // DEBUG: Log flash set size at start of draw (throttled to prevent crash)
        if (currentlyPlayingTasks.size > 0 && frameCounter % 50 === 0) { // Only log every 50th frame
            console.log(`üé® [DRAW] Drawing ${tasks.length} tasks, currentlyPlayingTasks.size=${currentlyPlayingTasks.size}`);
        }

        tasks.forEach(task => {
            // Find the correct agent row for this task (considering lanes)
            const taskLane = task._lane || 0;
            let agentIndex = -1;

            // Find agent row with matching agent_id and lane index
            for (let i = 0; i < agents.length; i++) {
                const agent = agents[i];
                if (agent.service_id === task.agent_id && agent._laneIndex === taskLane) {
                    agentIndex = i;
                    break;
                }
            }

            if (agentIndex === -1) {
                // Fallback: if lane not found, use first row for this agent
                agentIndex = agents.findIndex(a => a.service_id === task.agent_id);
                if (agentIndex === -1) return;
            }

            const rowHeight = ROW_HEIGHT * verticalZoom; // Apply vertical zoom
            const y = HEADER_HEIGHT + (agentIndex * rowHeight) - verticalOffset + ROW_PADDING; // Apply vertical offset
            const blockHeight = rowHeight - (2 * ROW_PADDING);

            // Check if task is currently playing sound (needs flash even if off-screen)
            const shouldFlash = currentlyPlayingTasks.has(task.task_id);

            // Skip if task block is not visible on screen AND not currently flashing
            if (!shouldFlash && (y + blockHeight < HEADER_HEIGHT || y > canvas.height)) return;

            // Calculate x position and width
            const taskStartTime = task.start_time;
            // FIX: For running tasks (no end_time), use current playhead position + duration estimate
            // For completed tasks, use actual end_time
            const taskEndTime = task.end_time || (taskStartTime + 30); // Default 30s for running tasks
            const duration = Math.max(taskEndTime - taskStartTime, 0.1); // Ensure positive, min 0.1s

            // x position is relative to timeline start (earliest task) minus timeline offset
            const relativeStart = taskStartTime - startTime;
            const x = AGENT_LABEL_WIDTH + ((relativeStart - timelineOffset) * pixelsPerSecond);
            const width = Math.max(duration * pixelsPerSecond, 2); // Min 2px width, scales with duration

            // Determine color based on status/progress
            const color = getTaskColor(task);

            // Draw block (FULL OPACITY - no transparency)
            ctx.fillStyle = color;
            ctx.globalAlpha = 1.0;
            ctx.fillRect(x, y, width, blockHeight);

            // Draw border for ALL tasks (makes them more visible)
            // Use colored border for multi-lane tasks to show lane assignment
            const agent = agents[agentIndex];
            const isMultiLane = agent && agent._laneCount > 1;

            if (isMultiLane) {
                // Color-code lanes: Lane 1 = blue, Lane 2 = green, Lane 3 = orange, etc.
                const laneColors = ['#60a5fa', '#34d399', '#fb923c', '#c084fc', '#fbbf24'];
                ctx.strokeStyle = laneColors[taskLane % laneColors.length];
                ctx.lineWidth = 2;
            } else {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = !task.end_time ? 3 : 1; // Thicker border for active tasks
            }
            ctx.strokeRect(x, y, width, blockHeight);

            // Reset alpha (already 1.0 but good practice)
            ctx.globalAlpha = 1.0;

            // Draw task text (if block is wide enough)
            if (width > 60) {
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 11px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';

                // Truncate text if needed
                const maxWidth = width - 10;
                let text = task.name || 'Task';
                const textWidth = ctx.measureText(text).width;

                if (textWidth > maxWidth) {
                    // Truncate with ellipsis
                    while (ctx.measureText(text + '...').width > maxWidth && text.length > 0) {
                        text = text.slice(0, -1);
                    }
                    text += '...';
                }

                // Draw text
                ctx.fillText(text, x + 5, y + blockHeight / 2);
            }

            // Draw bright flash overlay if task is currently playing sound
            // (shouldFlash already computed earlier at line 1203)
            if (shouldFlash) {
                // Only log first few flashes to prevent spam
                if (frameCounter < 10) {
                    console.log(`‚ú® [FLASH RENDER] Drawing flash for "${task.name}" (id=${task.task_id})`);
                }


                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)'; // Bright white overlay
                ctx.fillRect(x, y, width, blockHeight);

                // Add glowing border
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 4;
                ctx.shadowColor = '#ffffff';
                ctx.shadowBlur = 15;
                ctx.strokeRect(x, y, width, blockHeight);
                ctx.shadowBlur = 0; // Reset shadow
            }

            // Store block bounds for click detection
            task._bounds = { x, y, width, height: blockHeight };
        });
    }

    /**
     * Draw MINIMAL arrows showing ONLY completion reports flowing up the hierarchy
     *
     * SIMPLIFIED RULES:
     * - ONLY draw completion arrows (green UP) when child completes
     * - Arrow points VERTICALLY to parent's receive_report task
     * - NO delegation arrows (reduces clutter)
     * - NO generic arrows (only explicit completions)
     */
    function drawTaskArrows() {
        if (!tasks || tasks.length === 0) {
            console.log('[Arrows] No tasks to draw arrows for');
            return;
        }

        // DEBUG: Removed excessive arrow rendering start message

        // Build agent row Y-position map for arrow endpoints
        // CRITICAL: Map by (service_id, laneIndex) to handle multi-lane agents
        const agentRowMap = {};
        agents.forEach((agent, idx) => {
            const rowHeight = ROW_HEIGHT * verticalZoom; // Apply vertical zoom
            const yCenter = HEADER_HEIGHT + (idx * rowHeight) - verticalOffset + (rowHeight / 2);

            // Primary key: service_id only (for single-lane agents)
            if (!agentRowMap[agent.service_id]) {
                agentRowMap[agent.service_id] = yCenter;
            }

            // Secondary key: service_id + laneIndex (for multi-lane agents)
            const laneKey = `${agent.service_id}_lane${agent._laneIndex || 0}`;
            agentRowMap[laneKey] = yCenter;
        });

        // DEBUG: Removed excessive agentRowMap logging

        // Get animation offset for dashed lines (creates moving effect)
        const animOffset = (Date.now() / 50) % 10;  // Cycle every 500ms

        // Build a map of tasks by agent_id for quick lookup
        const tasksByAgent = {};
        tasks.forEach(task => {
            if (!tasksByAgent[task.agent_id]) {
                tasksByAgent[task.agent_id] = [];
            }
            tasksByAgent[task.agent_id].push(task);
        });

        // DEBUG: Removed excessive task grouping logging

        // üî• NEW: Build lookup table for tasks by log_id (for direct parent‚Üíchild relationships)
        const tasksByLogId = {};
        tasks.forEach(task => {
            if (task.log_id) {
                tasksByLogId[task.log_id] = task;
            }
        });
        // DEBUG: Removed excessive task indexing logging

        // Helper: Check if two tasks overlap in time
        function tasksOverlap(task1, task2) {
            const t1Start = task1.start_time;
            const t1End = task1.end_time || (t1Start + 9999); // Running task = infinite end
            const t2Start = task2.start_time;
            const t2End = task2.end_time || (t2Start + 9999);

            return t1Start < t2End && t2Start < t1End;
        }

        // Helper: Find parent task for a child task
        // REWRITTEN: Use most recent task on from_agent BEFORE child starts (sequential relationship)
        // Old logic required temporal overlap, but tasks are actually sequential (parent finishes, then child starts)
        function findParentTaskAtTime(fromAgent, childTask, timePoint) {
            const fromAgentTasks = tasksByAgent[fromAgent] || [];

            // Find the most recent task on from_agent that starts BEFORE this child task
            let bestParent = null;
            let bestTimeDiff = Infinity;

            for (const parentTask of fromAgentTasks) {
                // CRITICAL: Skip tasks without bounds (not rendered/visible on canvas)
                if (!parentTask._bounds) continue;

                // Skip if same task
                if (parentTask.task_id === childTask.task_id) continue;

                const pStart = parentTask.start_time;
                const cStart = childTask.start_time;

                // Parent should start BEFORE or AT THE SAME TIME as child
                // (allows both sequential and overlapping relationships)
                if (pStart <= cStart) {
                    const timeDiff = cStart - pStart;

                    // Find the closest parent (smallest time difference)
                    if (timeDiff < bestTimeDiff) {
                        bestTimeDiff = timeDiff;
                        bestParent = parentTask;
                    }
                }
            }

            return bestParent;
        }

        // Track tasks without arrows for debugging
        let tasksWithoutArrows = 0;
        let tasksWithoutRelationships = 0;

        // Draw arrows for each task
        let arrowsDrawn = 0;
        // DEBUG: Removed excessive arrow mode start logging
        tasks.forEach((task, idx) => {
            if (!task.from_agent || !task.to_agent) {
                tasksWithoutRelationships++;
                // Log ALL tasks without relationships (not just first 5)
                if (task.name.includes('Auth 001') || task.name.includes('Prog 002') || task.name.includes('Implement') || task.name.includes('Configure') || task.name.includes('Set up') || task.name.includes('Design')) {
                    console.warn(`‚ö†Ô∏è [Arrow Skip] "${task.name}" - Missing from_agent or to_agent (from=${task.from_agent}, to=${task.to_agent}, agent_id=${task.agent_id})`);
                }
                return;  // Skip if no relationship data
            }
            if (task.from_agent === 'user' || task.to_agent === 'user') {
                // DEBUG: Removed excessive arrow skip logging
                return;  // Skip user interactions
            }
            if (!task._bounds) {
                // DEBUG: Removed excessive arrow bounds logging
                return;
            }

            // DEBUG: Removed excessive arrow check logging

            // Get Y positions for from/to agents (use lane-specific position if available)
            // For child task (to_agent), use the task's actual lane assignment
            const childLaneKey = `${task.to_agent}_lane${task._lane || 0}`;
            const toY = agentRowMap[childLaneKey] || agentRowMap[task.to_agent];

            // For parent task (from_agent), we'll use the parent task's lane after finding it
            // (set below when parent is found)
            let fromY = agentRowMap[task.from_agent]; // Default fallback

            if (toY === undefined) return;  // Skip if agent not in visible agents list

            const taskStartX = task._bounds.x;  // Left edge of child task
            const taskEndX = task._bounds.x + task._bounds.width;  // Right edge
            const taskY = task._bounds.y + (task._bounds.height / 2); // Middle of task block

            // Determine task type (delegation vs report)
            const isReportAction = task.action_type === 'report' || task.action_type === 'receive_report' || task.name.toLowerCase().startsWith('completed ') || task.name.toLowerCase().includes('processing completion');

            // Skip report/receive_report tasks - they don't get delegation arrows
            if (isReportAction) {
                return;
            }

            // üî• UNIFIED ARROW LOGIC: Draw arrows for ALL parent‚Üíchild tasks (regardless of action_type)
            // - Assignment arrow (blue/purple): from parent to child at task START
            // - Completion arrow (green): from child to parent at task END

            // ASSIGNMENT ARROW (parent ‚Üí child at task START)
            if (task.from_agent !== task.to_agent && window.sequencerSettings?.showAssignmentArrows !== false) {
                // üî• NEW: Use parent_log_id for DIRECT parent lookup (no heuristics!)
                let parentTask = null;
                if (task.parent_log_id && tasksByLogId[task.parent_log_id]) {
                    parentTask = tasksByLogId[task.parent_log_id];
                } else {
                    // Fallback: Use heuristic matching (old behavior)
                    parentTask = findParentTaskAtTime(task.from_agent, task, task.start_time);
                }

                if (!parentTask && idx < 10) {
                    console.warn(`‚ö†Ô∏è [Arrow Skip] "${task.name}" - No parent found (parent_log_id=${task.parent_log_id})`);
                } else if (parentTask && !parentTask._bounds && idx < 10) {
                    console.warn(`‚ö†Ô∏è [Arrow Skip] "${task.name}" - Parent "${parentTask.name}" has no _bounds`);
                }

                if (parentTask && parentTask._bounds) {
                    // Use parent task's lane-specific Y position
                    const parentLaneKey = `${task.from_agent}_lane${parentTask._lane || 0}`;
                    const parentY = agentRowMap[parentLaneKey] || agentRowMap[task.from_agent];
                    const actualParentY = parentTask._bounds.y + (parentTask._bounds.height / 2);

                    // VERTICAL arrow at LEFT edge of child task (start time)
                    const arrowX = taskStartX + 5;  // Slightly inside left edge of child task block

                    drawArrow(
                        arrowX,        // VERTICAL - same X coordinate
                        actualParentY, // From: parent task Y (use actual bounds Y, not agentRowMap)
                        arrowX,        // VERTICAL - same X coordinate
                        taskY,         // To: child task Y
                        '#3b82f6',     // Blue
                        'solid',
                        'down',        // Downward arrow
                        animOffset
                    );
                    arrowsDrawn++;
                    // DEBUG: Removed excessive arrow success logging
                }
            }

            // COMPLETION ARROW (child ‚Üí parent at task END)
            const isCompleted = (task.status === 'done' || task.status === 'completed');
            const hasParentAgent = task.from_agent !== task.to_agent;
            const showCompletionEnabled = window.sequencerSettings?.showCompletionArrows !== false;

            // DEBUG: Removed excessive completion check logging

            if (isCompleted && hasParentAgent && showCompletionEnabled) {
                // Use same parent lookup as assignment arrow (parent_log_id)
                let parentTask = null;
                if (task.parent_log_id && tasksByLogId[task.parent_log_id]) {
                    parentTask = tasksByLogId[task.parent_log_id];
                } else {
                    // Fallback: Use heuristic matching
                    parentTask = findParentTaskAtTime(task.from_agent, task, task.start_time);
                }

                // DEBUG: Removed excessive completion arrow logging

                if (parentTask && parentTask._bounds) {
                    const actualParentY = parentTask._bounds.y + (parentTask._bounds.height / 2);
                    const arrowX = taskEndX - 5;  // Right edge of child task

                    // VERTICAL arrow from child back up to parent
                    drawArrow(
                        arrowX,        // VERTICAL - same X coordinate
                        taskY,         // From: child task Y
                        arrowX,        // VERTICAL - same X coordinate
                        actualParentY, // To: parent task Y
                        '#10b981',     // Green
                        'dashed',
                        'up',          // Upward arrow
                        animOffset
                    );
                    arrowsDrawn++;
                    // DEBUG: Removed excessive completion arrow success logging
                }
                // DEBUG: Removed excessive completion arrow skip logging
            }
        });

        // Log summary (throttled to prevent spam during playback)
        if (!window._lastArrowSummaryTime || Date.now() - window._lastArrowSummaryTime > 5000) {
            console.log(`üéØ [Arrows] Summary: ${arrowsDrawn} arrows drawn, ${tasksWithoutRelationships} tasks without relationships`, {
                showAssignmentArrows: window.sequencerSettings?.showAssignmentArrows,
                showCompletionArrows: window.sequencerSettings?.showCompletionArrows
            });
            window._lastArrowSummaryTime = Date.now();
        }
        if (tasksWithoutRelationships > 0) {
            console.warn(`‚ö†Ô∏è [Arrows] ${tasksWithoutRelationships}/${tasks.length} tasks missing from_agent/to_agent (no arrows drawn)`);
        }
        if (arrowsDrawn === 0 && tasks.length > 0) {
            console.error(`üî¥ [Arrows] ZERO arrows drawn despite having ${tasks.length} tasks! Check arrow logic.`);
        }
    }

    /**
     * Draw a single arrow with optional animation
     * @param {number} x1 - Start X coordinate
     * @param {number} y1 - Start Y coordinate
     * @param {number} x2 - End X coordinate
     * @param {number} y2 - End Y coordinate
     * @param {string} color - Arrow color
     * @param {string} style - 'solid' or 'dashed'
     * @param {string} direction - 'up' or 'down' (for arrowhead)
     * @param {number} animOffset - Animation offset for dashed lines
     */
    function drawArrow(x1, y1, x2, y2, color, style, direction, animOffset) {
        ctx.save();

        // Set line style
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;  // Keep original thickness
        ctx.globalAlpha = 0.8;  // Slightly more opaque than before (was 0.6)

        if (style === 'dashed') {
            ctx.setLineDash([5, 5]);
            ctx.lineDashOffset = -animOffset;  // Animated dashes
        } else {
            ctx.setLineDash([]);
        }

        // Draw line
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();

        // Draw arrowhead
        const arrowSize = 8;
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.8;  // More opaque arrowhead

        ctx.beginPath();
        if (direction === 'down') {
            // Downward arrow (‚ñº)
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - arrowSize / 2, y2 - arrowSize);
            ctx.lineTo(x2 + arrowSize / 2, y2 - arrowSize);
        } else if (direction === 'up') {
            // Upward arrow (‚ñ≤)
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - arrowSize / 2, y2 + arrowSize);
            ctx.lineTo(x2 + arrowSize / 2, y2 + arrowSize);
        } else if (direction === 'right') {
            // Rightward arrow (‚ñ∂)
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - arrowSize, y2 - arrowSize / 2);
            ctx.lineTo(x2 - arrowSize, y2 + arrowSize / 2);
        } else if (direction === 'left') {
            // Leftward arrow (‚óÄ)
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 + arrowSize, y2 - arrowSize / 2);
            ctx.lineTo(x2 + arrowSize, y2 + arrowSize / 2);
        }
        ctx.closePath();
        ctx.fill();

        ctx.restore();
    }

    function getTaskColor(task) {
        // DEBUG: Log task status and progress for first few tasks
        if (window._debugColorCounter === undefined) window._debugColorCounter = 0;
        if (window._debugColorCounter < 5) {
            console.log(`[DEBUG] Task "${task.name}" - status: "${task.status}", progress: ${task.progress}`);
            window._debugColorCounter++;
        }

        if (task.status === 'error' || task.status === 'stuck') {
            return statusColors.error;
        } else if (task.status === 'blocked' || task.status === 'waiting') {
            return statusColors.blocked;
        } else if (task.status === 'awaiting_approval') {
            return statusColors.awaiting_approval;
        } else if (task.status === 'done') {
            return statusColors.done;
        } else {
            // Running - determine color by progress
            const progress = task.progress || 0;
            if (progress < 0.25) return statusColors.running_0_25;
            if (progress < 0.75) return statusColors.running_25_75;
            return statusColors.running_75_100;
        }
    }

    function handleCanvasClick(event) {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        // Check if clicked on a task block
        const clickedTask = tasks.find(task => {
            if (!task._bounds) return false;
            const b = task._bounds;
            return x >= b.x && x <= b.x + b.width && y >= b.y && y <= b.y + b.height;
        });

        if (clickedTask) {
            console.log('Clicked task:', clickedTask);
            showTaskDetails(clickedTask, event);
        } else {
            // Clicked on timeline - move playhead (no timeline offset when stopped)
            const clickedTime = (x - AGENT_LABEL_WIDTH) / (PIXELS_PER_SECOND * zoomLevel);
            playheadPosition = Math.max(0, clickedTime);
            updatePlayhead();
            updateCurrentTime();
        }
    }

    function handleCanvasHover(event) {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        const hoveredTask = tasks.find(task => {
            if (!task._bounds) return false;
            const b = task._bounds;
            return x >= b.x && x <= b.x + b.width && y >= b.y && y <= b.y + b.height;
        });

        if (hoveredTask) {
            canvas.style.cursor = 'pointer';
            showTooltip(event, hoveredTask);
        } else {
            canvas.style.cursor = 'crosshair';
            hideTooltip();
        }
    }

    function showTooltip(event, task) {
        const tooltip = document.getElementById('tooltip');
        const agent = agents.find(a => a.service_id === task.agent_id);

        let content = `<div class="tooltip-title">${task.name || 'Task'}</div>`;
        content += `<div class="tooltip-row"><span class="tooltip-label">Agent:</span><span class="tooltip-value">${agent ? agent.name : 'Unknown'}</span></div>`;
        content += `<div class="tooltip-row"><span class="tooltip-label">Status:</span><span class="tooltip-value">${task.status}</span></div>`;
        content += `<div class="tooltip-row"><span class="tooltip-label">Progress:</span><span class="tooltip-value">${Math.round((task.progress || 0) * 100)}%</span></div>`;

        if (task.start_time) {
            const start = new Date(task.start_time * 1000);
            content += `<div class="tooltip-row"><span class="tooltip-label">Started:</span><span class="tooltip-value">${start.toLocaleTimeString()}</span></div>`;
        }

        if (task.end_time) {
            const end = new Date(task.end_time * 1000);
            content += `<div class="tooltip-row"><span class="tooltip-label">Ended:</span><span class="tooltip-value">${end.toLocaleTimeString()}</span></div>`;
        }

        // FIX: Don't use Date.now() for old tasks - estimate 30s for running tasks
        const hasRunningStatus = ['running', 'blocked', 'waiting'].includes(task.status);
        const estimatedEnd = hasRunningStatus ? (task.start_time + 30) : (task.start_time + 30);
        const duration = (task.end_time || estimatedEnd) - task.start_time;
        content += `<div class="tooltip-row"><span class="tooltip-label">Duration:</span><span class="tooltip-value">${formatDuration(duration)}</span></div>`;

        tooltip.innerHTML = content;
        tooltip.style.left = `${event.pageX + 10}px`;
        tooltip.style.top = `${event.pageY - 10}px`;
        tooltip.classList.add('visible');
    }

    function hideTooltip() {
        document.getElementById('tooltip').classList.remove('visible');
    }

    function showTaskDetails(task, event) {
        // Could open a modal or sidebar with full task details
        console.log('Task details:', task);
    }

    function formatDuration(seconds) {
        // FIX: Ensure seconds is positive (handle negative durations)
        const absSecs = Math.abs(seconds);
        const hours = Math.floor(absSecs / 3600);
        const minutes = Math.floor((absSecs % 3600) / 60);
        const secs = Math.floor(absSecs % 60);

        if (hours > 0) {
            return `${hours}h ${minutes}m ${secs}s`;
        } else if (minutes > 0) {
            return `${minutes}m ${secs}s`;
        } else {
            return `${secs}s`;
        }
    }

    function updatePlayhead() {
        const pixelsPerSecond = PIXELS_PER_SECOND * zoomLevel;

        // FIXED: Playhead at LEFT edge (like music sequencers)
        // Tasks scroll right-to-left past the playhead during playback
        // Sounds trigger when tasks cross this line
        const fixedPlayheadX = AGENT_LABEL_WIDTH;
        document.getElementById('playhead').style.left = `${fixedPlayheadX}px`;
    }

    function togglePlayPause() {
        isPlaying = !isPlaying;
        const icon = document.getElementById('play-icon');
        const text = document.getElementById('play-text');
        const btn = document.getElementById('play-pause-btn');

        if (isPlaying) {
            // Reset frame counter at playback start
            frameCounter = 0;

            icon.textContent = '‚è∏Ô∏è';
            text.textContent = 'Pause';
            btn.classList.add('active');

            console.log('‚ñ∂Ô∏è [PLAY] Starting playback for task:', projectTaskId);

            // Immediate refresh on play to get latest task data
            fetchSequencerData().then(() => {
                console.log('‚úÖ [PLAY] Data refreshed before playback');
                startPlayback();
            });
        } else {
            icon.textContent = '‚ñ∂Ô∏è';
            text.textContent = 'Play';
            btn.classList.remove('active');

            console.log('‚è∏Ô∏è [PAUSE] Pausing playback');

            // CRITICAL: Clear the playback timer when pausing
            if (playbackTimer) {
                clearTimeout(playbackTimer);
                playbackTimer = null;
            }
        }
    }

    // Playback timer reference (so we can cancel it)
    let playbackTimer = null;

    function startPlayback() {
        // CRITICAL: Clear any existing timer first
        if (playbackTimer) {
            clearTimeout(playbackTimer);
            playbackTimer = null;
        }

        // Check if still playing (user might have paused)
        if (!isPlaying) {
            return; // Exit cleanly, no more scheduling
        }

        // Increment frame counter for console protection
        frameCounter++;

        // Advance by 0.1 seconds * playback speed
        playheadPosition += (0.1 * playbackSpeed);
        timelineOffset += (0.1 * playbackSpeed); // Pan timeline (tasks slide right to left)

        // Check if we've scrolled past the maximum time (relative to timeline start)
        if (tasks.length > 0) {
            const earliestTime = Math.min(...tasks.map(t => t.start_time));
            // FIX: Don't use Date.now() for old tasks - use actual task times
            const latestTime = Math.max(...tasks.map(t => {
                if (t.end_time) return t.end_time;
                // For running tasks, use a reasonable estimate based on start_time
                // Don't use current playback position as it causes resets
                return t.start_time + 300; // 5 minutes estimate for running tasks
            }));
            const maxTime = latestTime - earliestTime;

            // Log position every N frames to reduce console spam (increased from 100 to 500)
            if (frameCounter % 100 === 0) { // More frequent logging to debug the reset issue
                console.log(`‚ñ∂Ô∏è [PLAYBACK] Position: ${playheadPosition.toFixed(1)}s / ${maxTime.toFixed(1)}s (${((playheadPosition/maxTime)*100).toFixed(0)}%)`);
            }

            // DEBUG: Log when approaching potential reset point
            if (playheadPosition > 50 && playheadPosition < 65) {
                console.log(`üîç [PLAYBACK DEBUG] Approaching 1min mark: playheadPosition=${playheadPosition.toFixed(1)}s, maxTime=${maxTime.toFixed(1)}s, earliestTime=${earliestTime}, latestTime=${latestTime}`);
            }

            // FIX: Stop playback when reaching end instead of looping
            if (playheadPosition >= maxTime) {
                // CRITICAL: Set isPlaying = false AND clear timer BEFORE returning
                isPlaying = false;
                if (playbackTimer) {
                    clearTimeout(playbackTimer);
                    playbackTimer = null;
                }

                console.log('üèÅ [PLAYBACK] Reached end - stopping');

                document.getElementById('play-icon').textContent = '‚ñ∂Ô∏è';
                document.getElementById('play-text').textContent = 'Play';
                document.getElementById('play-pause-btn').classList.remove('active');

                // Keep playhead at the end position (don't reset to 0)
                playheadPosition = maxTime;
                timelineOffset = maxTime;

                // Final redraw at end position
                drawSequencer();
                updatePlayhead();
                updateCurrentTime();

                return; // Exit cleanly, no more scheduling
            }
        }

        drawSequencer(); // Redraw entire scene (tasks will shift left)
        updatePlayhead();
        updateCurrentTime();

        // Check if playhead crossed any task boundaries for sound
        checkTaskEvents();

        // Schedule next frame ONLY if still playing
        if (isPlaying) {
            playbackTimer = setTimeout(startPlayback, 100); // Update every 100ms
        }
    }

    // Track which task boundaries have been crossed (start and end separately)
    let lastTriggeredTaskStarts = new Set();
    let lastTriggeredTaskEnds = new Set();
    let lastPlayheadPosition = 0;
    let previousTaskStates = new Map(); // Track previous task states for real-time sound triggering
    let currentlyPlayingTasks = new Set(); // Track tasks currently playing sound (for visual flash)

    /**
     * Detect real-time task status changes and trigger sounds immediately.
     * This runs when new task data is fetched (during Start Demo execution).
     */
    function detectRealtimeTaskChanges(newTasks) {
        // Check if sound is enabled
        const settings = typeof getSettings === 'function' ? getSettings() : {};
        const effectiveSoundMode = soundMode !== 'none' ? soundMode : (settings.defaultSoundMode || 'none');

        if (effectiveSoundMode === 'none') {
            return; // Sound disabled
        }

        // Check each task for status changes
        newTasks.forEach(task => {
            const taskId = task.task_id;
            const currentState = {
                status: task.status,
                hasEndTime: !!task.end_time
            };

            const previousState = previousTaskStates.get(taskId);

            if (!previousState) {
                // New task detected - trigger "task started" sound
                // Reduced logging to prevent Chrome crash
                queueSound('task_started', task);
                previousTaskStates.set(taskId, currentState);
            } else {
                // Check for status changes
                const statusChanged = (previousState.status !== currentState.status);
                const justCompleted = (!previousState.hasEndTime && currentState.hasEndTime);

                if (statusChanged || justCompleted) {
                    // Task status changed - trigger appropriate sound
                    const eventType = task.status === 'done' ? 'task_completed' :
                                     task.status === 'error' ? 'error' :
                                     task.status === 'blocked' ? 'warning' :
                                     'task_completed';

                    // Reduced logging to prevent Chrome crash
                    queueSound(eventType, task);
                    previousTaskStates.set(taskId, currentState);
                }
            }
        });

        // Clean up old tasks that no longer exist (garbage collection)
        const currentTaskIds = new Set(newTasks.map(t => t.task_id));
        for (const taskId of previousTaskStates.keys()) {
            if (!currentTaskIds.has(taskId)) {
                previousTaskStates.delete(taskId);
            }
        }
    }

    function checkTaskEvents() {
        // CRITICAL: Only check for sound events during active playback
        if (!isPlaying) {
            return; // Don't trigger sounds when paused/stopped
        }

        // Check if sound is enabled (from settings or local dropdown)
        const settings = typeof getSettings === 'function' ? getSettings() : {};
        const effectiveSoundMode = soundMode !== 'none' ? soundMode : (settings.defaultSoundMode || 'none');

        if (effectiveSoundMode === 'none') {
            return; // Sound disabled (no logging needed)
        }

        // üî¥ FIX: Use playheadPosition (playback cursor position in timeline)
        // NOT Date.now() (real-world time)!
        const startTime = window._sequencerStartTime || 0;
        const currentPlaybackTime = startTime + playheadPosition; // Absolute time on timeline
        const previousPlaybackTime = startTime + (lastPlayheadPosition || 0);

        let soundsTriggered = 0;

        // Find tasks that crossed the playhead since last frame
        // CRITICAL: Only trigger sounds for tasks that are VISIBLE near the NOW line
        const pixelsPerSecond = PIXELS_PER_SECOND * zoomLevel;
        const nowX = AGENT_LABEL_WIDTH; // NOW line is at left edge
        
        tasks.forEach(task => {
            const taskStart = task.start_time;
            const hasRunningStatus = ['running', 'blocked', 'waiting'].includes(task.status);
            // CRITICAL: Use actual end_time if available, don't default to 30 seconds
            const taskEnd = task.end_time;

            // DEBUG: Log first few tasks to check time data (more detailed)
            if (frameCounter < 10) {
                console.log(`üïê [TIME DEBUG] Task "${task.name}": start_time=${task.start_time}, end_time=${task.end_time}, status=${task.status}, hasRunning=${hasRunningStatus}`);
            }

            // Skip tasks without valid timing
            if (!taskStart || (!taskEnd && !hasRunningStatus)) {
                return;
            }

            const taskStartKey = `${task.task_id}_start`;
            const taskEndKey = `${task.task_id}_end`;

            // Check if playhead crossed task START (simple time-based check)
            // This happens when: previousPlaybackTime < taskStart <= currentPlaybackTime
            const hasMoved = Math.abs(currentPlaybackTime - previousPlaybackTime) > 0.01; // Moved at least 10ms
            const crossedStart = previousPlaybackTime < taskStart && taskStart <= currentPlaybackTime;
            const notYetTriggered = !lastTriggeredTaskStarts.has(taskStartKey);

            if (crossedStart && notYetTriggered && hasMoved) {
                lastTriggeredTaskStarts.add(taskStartKey);
                soundsTriggered++;

                const eventType = 'task_started';
                // Only log sound triggers every N frames OR first 3 triggers (reduced from 5)
                if (frameCounter % 1000 === 0 || soundsTriggered <= 3) {
                    console.log(`üéµ Task started: "${task.name}"`);
                }
                queueSound(eventType, task);
            }

            // Check if playhead crossed task END (only if task has an end_time)
            if (taskEnd && previousPlaybackTime < taskEnd && taskEnd <= currentPlaybackTime && !lastTriggeredTaskEnds.has(taskEndKey) && hasMoved) {
                lastTriggeredTaskEnds.add(taskEndKey);
                soundsTriggered++;

                const eventType = task.status === 'done' ? 'task_completed' :
                                 task.status === 'error' ? 'error' :
                                 task.status === 'blocked' ? 'warning' :
                                 'task_completed';

                // Only log sound triggers every N frames OR first 3 triggers (reduced from 5)
                if (frameCounter % 1000 === 0 || soundsTriggered <= 3) {
                    console.log(`üéµ Task ended: "${task.name}" (${eventType})`);
                }
                queueSound(eventType, task);
            }
        });

        // Update last position for next frame
        lastPlayheadPosition = playheadPosition;

        // Clean up triggered tasks when playhead loops back to start
        if (playheadPosition < 1) {
            lastTriggeredTaskStarts.clear();
            lastTriggeredTaskEnds.clear();
            currentlyPlayingTasks.clear(); // Clear visual flashes on loop
        }
    }

    // Sound queue to prevent overlapping sounds
    let soundQueue = [];
    let currentlyPlaying = false;

    function queueSound(eventType, task) {
        soundQueue.push({ eventType, task, timestamp: Date.now() });

        // Start processing queue if not already playing
        if (!currentlyPlaying) {
            processNextSound();
        }
    }

    function processNextSound() {
        // CRITICAL: Check if queue is empty FIRST
        if (soundQueue.length === 0) {
            currentlyPlaying = false;
            return; // EXIT - do NOT schedule another call
        }

        // Mark as playing to prevent duplicate processing
        currentlyPlaying = true;

        const { eventType, task } = soundQueue.shift();

        // Add task to currently playing set for visual flash
        if (task && task.task_id) {
            currentlyPlayingTasks.add(task.task_id);

            // Get note duration from settings (default 150ms)
            const settings = typeof getSettings === 'function' ? getSettings() : {};
            const noteDuration = settings.sequencerNoteDuration || 150;

            // Remove from set after note duration + small buffer
            setTimeout(() => {
                currentlyPlayingTasks.delete(task.task_id);
                drawSequencer(); // Redraw to remove flash
            }, noteDuration + 50); // 50ms buffer

            // Trigger immediate redraw to show flash
            drawSequencer();
        } else {
            console.warn(`‚ö†Ô∏è [FLASH] Task missing task_id:`, task);
        }

        // Call the sound handler (defined in base.html) - pass task for pitch calculation
        if (typeof handleTaskEventSound === 'function') {
            handleTaskEventSound(eventType, task);
        }

        // CRITICAL: Only schedule next call if queue still has items
        if (soundQueue.length > 0) {
            setTimeout(() => {
                processNextSound(); // Process next item in queue
            }, 10); // Small delay to avoid blocking
        } else {
            // Queue is empty - mark as not playing
            currentlyPlaying = false;
        }
    }

    // Track stop button clicks for double-click rewind
    let lastStopClickTime = 0;
    const DOUBLE_CLICK_THRESHOLD = 500; // 500ms

    function resetPlayhead() {
        const now = Date.now();
        const timeSinceLastClick = now - lastStopClickTime;

        // Check if this is a double-click (within 500ms)
        if (timeSinceLastClick < DOUBLE_CLICK_THRESHOLD) {
            // REWIND: Reset to beginning (time 0)
            playheadPosition = 0;
            timelineOffset = 0;
            lastTriggeredTaskStarts.clear();
            lastTriggeredTaskEnds.clear();
            currentlyPlayingTasks.clear(); // Clear visual flashes
            lastPlayheadPosition = 0;
            frameCounter = 0; // Reset frame counter
            console.log('‚è™ [REWIND] Double-click detected - rewinding to start');
            lastStopClickTime = 0; // Reset to prevent triple-click

            // Immediate refresh on rewind to get latest data
            fetchSequencerData().then(() => {
                console.log('‚úÖ [REWIND] Data refreshed');
                drawSequencer();
            });
        } else {
            // Single click: Just stop playback
            console.log('‚èπÔ∏è [STOP] Single click - stopping playback');
        }

        // Always stop playback
        isPlaying = false;

        // CRITICAL: Cancel the playback timer
        if (playbackTimer) {
            clearTimeout(playbackTimer);
            playbackTimer = null;
            console.log('‚úÖ [STOP] Playback timer cleared');
        }

        document.getElementById('play-icon').textContent = '‚ñ∂Ô∏è';
        document.getElementById('play-text').textContent = 'Play';
        document.getElementById('play-pause-btn').classList.remove('active');

        // Update last click time
        lastStopClickTime = now;

        updatePlayhead();
        updateCurrentTime();
        drawSequencer(); // Redraw to show new position
    }

    /**
     * Handle Prime Directive completion signal from PAS ROOT
     */
    function handleDirectiveComplete(completionTask) {
        console.log('üéØ [PRIME DIRECTIVE COMPLETE]', completionTask);

        projectComplete = true;

        // 1. Stop playback and auto-scroll
        isPlaying = false;
        document.getElementById('play-icon').textContent = '‚ñ∂Ô∏è';
        document.getElementById('play-text').textContent = 'Play';
        document.getElementById('play-pause-btn').classList.remove('active');

        // 2. Stop polling for updates
        if (refreshIntervalId) {
            clearInterval(refreshIntervalId);
            refreshIntervalId = null;
            console.log('‚è∏Ô∏è [COMPLETION] Stopped auto-refresh');
        }

        // 3. Parse completion data
        let completionData = {};
        try {
            completionData = JSON.parse(completionTask.action_data || '{}');
        } catch (e) {
            console.warn('Could not parse completion data:', e);
        }

        // 4. Show END OF PROJECT banner
        showEndOfProjectBanner(completionData);

        // 5. Scroll to end of timeline (show final state)
        setTimeout(() => {
            scrollToTimelineEnd();
        }, 500);
    }

    function showEndOfProjectBanner(data) {
        // Remove old banner if exists
        const oldBanner = document.getElementById('end-of-project-banner');
        if (oldBanner) oldBanner.remove();

        // Create banner overlay
        const banner = document.createElement('div');
        banner.id = 'end-of-project-banner';
        banner.style.cssText = `
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px 60px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            z-index: 10000;
            text-align: center;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            animation: slideDown 0.5s ease-out;
        `;

        const passIcon = data.validation_pass ? '‚úÖ' : '‚ö†Ô∏è';
        const statusText = data.validation_pass ? 'Completed Successfully' : 'Completed with Issues';

        banner.innerHTML = `
            <div style="font-size: 72px; margin-bottom: 20px;">üèÅ</div>
            <h1 style="font-size: 48px; margin: 0 0 10px 0; font-weight: bold;">
                END OF PROJECT
            </h1>
            <p style="font-size: 24px; margin: 10px 0; opacity: 0.9;">
                ${passIcon} ${statusText}
            </p>
            <div style="margin-top: 30px; font-size: 18px; opacity: 0.8;">
                <div>Tasks: ${data.tasks_succeeded || 0} succeeded, ${data.tasks_failed || 0} failed (${data.tasks_total || 0} total)</div>
                <div>Duration: ${data.duration_seconds || 0}s</div>
            </div>
            <button onclick="closeEndOfProjectBanner()" style="
                margin-top: 30px;
                padding: 15px 40px;
                font-size: 18px;
                background: white;
                color: #667eea;
                border: none;
                border-radius: 10px;
                cursor: pointer;
                font-weight: bold;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            ">
                View Final State
            </button>
        `;

        document.body.appendChild(banner);
    }

    function closeEndOfProjectBanner() {
        const banner = document.getElementById('end-of-project-banner');
        if (banner) {
            banner.style.animation = 'slideUp 0.3s ease-in';
            setTimeout(() => banner.remove(), 300);
        }

        // Scroll to show final state
        scrollToTimelineEnd();
    }

    function scrollToTimelineEnd() {
        // Find last task time
        if (tasks.length === 0) return;

        const lastTask = tasks.reduce((latest, task) => {
            const taskEnd = task.end_time || task.start_time;
            const latestEnd = latest.end_time || latest.start_time;
            return taskEnd > latestEnd ? task : latest;
        });

        const lastTime = lastTask.end_time || lastTask.start_time;
        const startTime = window._sequencerStartTime || Date.now() / 1000;

        // Scroll to show last 30 seconds
        timelineOffset = Math.max(0, lastTime - startTime - 30);
        updatePlayhead();
        drawSequencer();
    }

    /**
     * Toggle arrow visibility
     */
    /**
     * Change arrow display mode
     * @param {string} mode - 'all', 'start-only', 'end-only', 'start-end', or 'none'
     */
    function changeArrowMode(mode) {
        if (!window.sequencerSettings) window.sequencerSettings = {};

        // Set flags based on mode
        switch (mode) {
            case 'all':
                window.sequencerSettings.showAssignmentArrows = true;
                window.sequencerSettings.showCompletionArrows = true;
                break;
            case 'start-only':
                window.sequencerSettings.showAssignmentArrows = true;
                window.sequencerSettings.showCompletionArrows = false;
                break;
            case 'end-only':
                window.sequencerSettings.showAssignmentArrows = false;
                window.sequencerSettings.showCompletionArrows = true;
                break;
            case 'start-end':
                window.sequencerSettings.showAssignmentArrows = true;
                window.sequencerSettings.showCompletionArrows = true;
                break;
            case 'none':
                window.sequencerSettings.showAssignmentArrows = false;
                window.sequencerSettings.showCompletionArrows = false;
                break;
            default:
                window.sequencerSettings.showAssignmentArrows = true;
                window.sequencerSettings.showCompletionArrows = true;
        }

        // Save to localStorage
        window.sequencerSettings.arrowMode = mode;
        localStorage.setItem('sequencerSettings', JSON.stringify(window.sequencerSettings));

        console.log('üéØ ARROW MODE CHANGED TO:', mode, {
            showAssignmentArrows: window.sequencerSettings.showAssignmentArrows,
            showCompletionArrows: window.sequencerSettings.showCompletionArrows
        });

        drawSequencer();  // Redraw with new settings
    }

    /**
     * Change deduplication mode
     */
    function changeDedupMode(mode) {
        if (!window.sequencerSettings) window.sequencerSettings = {};
        window.sequencerSettings.dedupMode = mode;

        // Reload data with new dedup mode
        const taskId = document.getElementById('project-select')?.value;
        if (taskId) {
            loadSequencerData(taskId, false);  // Reload with new mode
        }
    }

    function fitAll() {
        // Reset timeline offset and zoom to show all tasks
        timelineOffset = 0;
        playheadPosition = 0;
        verticalOffset = 0;

        if (tasks.length === 0) {
            // No tasks, reset to default zoom
            zoomLevel = 1.0;
            verticalZoom = 1.0;
            document.getElementById('zoom-level').textContent = '100%';
            document.getElementById('vertical-zoom-value').textContent = '100%';
            drawSequencer();
            updatePlayhead();
            updateCurrentTime();
            return;
        }

        // HORIZONTAL ZOOM: Fit all tasks in viewport width
        const taskTimes = tasks.flatMap(t => [t.start_time, t.end_time || t.start_time]);
        const earliestTime = Math.min(...taskTimes);
        const latestTime = Math.max(...taskTimes);
        const totalDuration = latestTime - earliestTime || 300; // Default 5 min if no duration

        const canvasWrapper = document.getElementById('sequencer-canvas-wrapper');
        const availableWidth = canvasWrapper.clientWidth - AGENT_LABEL_WIDTH - 50; // 50px padding
        const requiredPixels = totalDuration * PIXELS_PER_SECOND;

        if (requiredPixels > availableWidth) {
            // Zoom out to fit
            zoomLevel = availableWidth / requiredPixels;
        } else {
            // Zoom in to fill viewport (but don't over-zoom)
            zoomLevel = Math.min(availableWidth / requiredPixels, 2.0); // Max 2x zoom for fit
        }

        // VERTICAL ZOOM: Fit all agents in viewport height
        const availableHeight = canvasWrapper.clientHeight - HEADER_HEIGHT - 50; // 50px padding
        const requiredHeight = agents.length * ROW_HEIGHT;
        
        if (requiredHeight > availableHeight) {
            // Zoom out to fit all agents
            verticalZoom = availableHeight / requiredHeight;
        } else {
            // Zoom in to fill viewport (but don't over-zoom)
            verticalZoom = Math.min(availableHeight / requiredHeight, 2.0); // Max 2x zoom for fit
        }

        // Clamp zoom levels
        zoomLevel = Math.max(0.1, Math.min(zoomLevel, 10.0)); // Clamp between 0.1x and 10x
        verticalZoom = Math.max(0.3, Math.min(verticalZoom, 3.0)); // Clamp between 0.3x and 3.0x

        // Update displays
        document.getElementById('zoom-level').textContent = Math.round(zoomLevel * 100) + '%';
        document.getElementById('vertical-zoom-value').textContent = Math.round(verticalZoom * 100) + '%';
        
        // Update sliders
        const zoomSlider = document.getElementById('zoom-slider');
        const verticalSlider = document.getElementById('vertical-zoom-slider');
        zoomSlider.value = zoomToSlider(zoomLevel);
        verticalSlider.value = (verticalZoom - 0.3) / (3.0 - 0.3) * 100; // Map to 0-100 range

        // Persist settings
        localStorage.setItem('sequencer_zoomLevel', zoomLevel);
        localStorage.setItem('sequencer_verticalZoom', verticalZoom);

        drawSequencer();
        updatePlayhead();
        updateCurrentTime();
    }

    function updateCurrentTime() {
        // Show current NOW position in timeline (not real-world clock)
        const startTime = window._sequencerStartTime || 0;
        const currentTimelineTime = startTime + playheadPosition; // Current NOW position
        
        // Format as relative time from start (e.g., "+00:45" = 45 seconds into timeline)
        const relativeTime = currentTimelineTime - startTime;
        const minutes = Math.floor(relativeTime / 60);
        const seconds = Math.floor(relativeTime % 60);
        
        const timeString = `+${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        document.getElementById('current-time').textContent = timeString;
    }

    /**
     * Convert slider position (0-100) to zoom level (0.1x-20x) using logarithmic scaling.
     * - 0%: 0.1x (10%, zoomed out)
     * - 50%: 1.0x (100%, normal)
     * - 100%: 20x (2000%, zoomed in)
     */
    function sliderToZoom(sliderValue) {
        const val = parseFloat(sliderValue);
        // Logarithmic scale: zoom = 0.1 * 10^(val/33.33)
        // At val=0: zoom = 0.1 * 10^0 = 0.1
        // At val=33.33: zoom = 0.1 * 10^1 = 1.0
        // At val=66.66: zoom = 0.1 * 10^2 = 10.0
        // At val=100: zoom = 0.1 * 10^3 = 100.0 (capped at 20)
        const zoom = 0.1 * Math.pow(10, val / 33.33);
        return Math.min(zoom, 20.0); // Cap at 20x
    }

    /**
     * Convert zoom level to slider position (inverse logarithmic)
     */
    function zoomToSlider(zoom) {
        const sliderPos = 33.33 * Math.log10(zoom / 0.1);
        return Math.max(0, Math.min(100, sliderPos));
    }

    /**
     * Update zoom from slider input (logarithmic scaling)
     */
    function updateZoomFromSlider(sliderValue) {
        const zoom = sliderToZoom(sliderValue);
        updateZoom(zoom);
    }

    /**
     * Update zoom level directly
     */
    function updateZoom(zoom) {
        zoomLevel = parseFloat(zoom);
        localStorage.setItem('sequencer_zoomLevel', zoomLevel); // Persist zoom level

        // Update slider and display
        const slider = document.getElementById('zoom-slider');
        const display = document.getElementById('zoom-level');

        slider.value = zoomToSlider(zoomLevel);
        display.textContent = Math.round(zoomLevel * 100) + '%';

        resizeCanvas();
    }

    function zoomIn() {
        updateZoom(Math.min(zoomLevel * 1.5, 20.0));
    }

    function zoomOut() {
        updateZoom(Math.max(zoomLevel / 1.5, 0.1));
    }

    function changeTimeRange() {
        timeRangeSeconds = parseInt(document.getElementById('time-range').value);
        localStorage.setItem('sequencer_timeRange', timeRangeSeconds); // Persist selection
        playheadPosition = 0;
        updatePlayhead();
        fetchSequencerData();
    }

    async function refreshSequencer() {
        await fetchSequencerData();
    }

    /**
     * Convert slider position (0-100) to playback speed (0.1x-1000x) using logarithmic scaling.
     * - Uses logarithmic scale for smooth acceleration across wide range
     * - 0%: 0.1x (slowest)
     * - 25%: 1.0x (normal speed)
     * - 50%: 10x
     * - 75%: 100x
     * - 100%: 1000x (fastest)
     */
    function sliderToSpeed(sliderValue) {
        const val = parseFloat(sliderValue);

        // Logarithmic scale: speed = 0.1 * 10^(val/25)
        // This gives us: 0.1x at 0%, 1x at 25%, 10x at 50%, 100x at 75%, 1000x at 100%
        const speed = 0.1 * Math.pow(10, val / 25);

        return speed;
    }

    /**
     * Convert playback speed (0.1x-1000x) to slider position (0-100) using inverse logarithmic function.
     */
    function speedToSlider(speed) {
        // Inverse: val = 25 * log10(speed / 0.1)
        const sliderPos = 25 * Math.log10(speed / 0.1);

        // Clamp to valid range
        return Math.max(0, Math.min(100, sliderPos));
    }

    /**
     * Update playback speed from slider input (handles non-linear scaling).
     */
    function updatePlaybackSpeedFromSlider(sliderValue, source) {
        const speed = sliderToSpeed(sliderValue);
        updatePlaybackSpeed(speed, source);
    }

    /**
     * Update playback speed directly (called programmatically or from settings).
     */
    function updatePlaybackSpeed(speed, source) {
        playbackSpeed = parseFloat(speed);

        // Update slider and display (only bottom control now)
        const bottomSlider = document.getElementById('playback-speed-bottom');
        const bottomValue = document.getElementById('speed-value-bottom');

        const sliderPos = speedToSlider(playbackSpeed);

        // Always update the display text, regardless of source
        if (source !== 'bottom') {
            bottomSlider.value = sliderPos;
        }
        bottomValue.textContent = formatSpeed(playbackSpeed); // Update display text for all sources

        console.log('Playback speed set to:', playbackSpeed + 'x (slider position:', sliderPos + ')');
    }

    /**
     * Format speed value for display.
     */
    function formatSpeed(speed) {
        if (speed < 1.0) {
            return speed.toFixed(2) + 'x';
        } else if (speed < 10.0) {
            return speed.toFixed(1) + 'x';
        } else {
            return Math.round(speed) + 'x';
        }
    }

    /**
     * Update vertical scroll from slider (0-100 maps to scroll range)
     */
    function updateVerticalScrollFromSlider(sliderValue) {
        const percentage = parseInt(sliderValue);

        // Calculate max vertical scroll (total height - viewport height)
        const rowHeight = ROW_HEIGHT * verticalZoom;
        const totalHeight = agents.length * rowHeight;
        const viewportHeight = canvas.height - HEADER_HEIGHT;
        const maxScroll = Math.max(0, totalHeight - viewportHeight);

        // Map slider (0-100) to scroll range (0-maxScroll)
        verticalOffset = (percentage / 100) * maxScroll;

        // Update display
        document.getElementById('vertical-scroll-value').textContent = percentage + '%';

        // Redraw
        drawSequencer();
    }

    /**
     * Update vertical zoom from slider (0-100 maps to 0.3x - 3.0x)
     */
    function updateVerticalZoomFromSlider(sliderValue) {
        const percentage = parseInt(sliderValue);

        // Map slider (0-100) to zoom range (0.3 - 3.0)
        // At 0%: 0.3x, At 50%: 1.0x, At 100%: 3.0x
        // Use logarithmic scale similar to playback speed
        const minZoom = 0.3;
        const maxZoom = 3.0;
        const range = maxZoom - minZoom;

        // Linear interpolation for simplicity
        verticalZoom = minZoom + (percentage / 100) * range;
        localStorage.setItem('sequencer_verticalZoom', verticalZoom); // Persist vertical zoom

        // Update display
        const displayValue = Math.round(verticalZoom * 100);
        document.getElementById('vertical-zoom-value').textContent = displayValue + '%';

        // Redraw
        drawSequencer();
    }

    function changeSoundMode() {
        const soundSelect = document.getElementById('sound-mode');
        soundMode = soundSelect.value;

        console.log('Sound mode changed to:', soundMode);

        // Show notification about sound mode
        if (soundMode !== 'none') {
            console.log('üîä Sound enabled:', soundMode);
            // Future: Initialize audio context based on selected mode
            // - 'voice': Initialize Web Speech API for TTS
            // - 'music': Initialize Web Audio API for musical notes
            // - 'random': Load sound effect library
        } else {
            console.log('üîá Sound disabled');
        }
    }

    // Apply settings to sequencer view
    function applyViewSettings(settings) {
        console.log('Applying sequencer settings:', settings);

        // Clear existing auto-refresh timer
        if (autoRefreshTimer) {
            clearInterval(autoRefreshTimer);
            autoRefreshTimer = null;
        }

        // Setup auto-refresh if enabled
        if (settings.autoRefreshEnabled) {
            const intervalMs = settings.refreshInterval * 1000;
            console.log('Setting up auto-refresh every', settings.refreshInterval, 'seconds');
            autoRefreshTimer = setInterval(refreshSequencer, intervalMs);
        } else {
            console.log('Auto-refresh disabled');
        }

        // Apply sequencer-specific settings
        if (settings.defaultPlaybackSpeed) {
            updatePlaybackSpeed(settings.defaultPlaybackSpeed, 'settings');
        }

        if (settings.defaultSoundMode) {
            soundMode = settings.defaultSoundMode;
            const soundSelect = document.getElementById('sound-mode');
            if (soundSelect) {
                soundSelect.value = soundMode;
            }
        }

        // Apply scrollbar visibility
        const canvasWrapper = document.getElementById('sequencer-canvas-wrapper');
        if (canvasWrapper) {
            if (settings.hideScrollbars) {
                canvasWrapper.style.overflow = 'hidden';
            } else {
                canvasWrapper.style.overflow = 'auto';
            }
        }
    }

    // Poll for new tasks when demo is running
    async function pollForActiveTasks() {
        try {
            // Check if demo is running
            const demoResponse = await fetch('/api/demo/status');
            const demoData = await demoResponse.json();

            if (demoData.running) {
                // Demo is active - refresh sequencer data
                await refreshSequencer();
            }
        } catch (error) {
            console.error('Error polling for active tasks:', error);
        }
    }

    // Load projects into dropdown
    async function loadProjects() {
        try {
            const response = await fetch('/api/actions/projects');

            // FIX: Handle non-200 responses gracefully
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();

            const selector = document.getElementById('project-selector');
            selector.innerHTML = '';  // Clear loading message

            if (data.projects && data.projects.length > 0) {
                // Add projects sorted by most recent first (already sorted by backend)
                data.projects.forEach((project, index) => {
                    const option = document.createElement('option');
                    option.value = project.task_id;

                    // Format display name with status indicator
                    const statusIcon = project.is_running ? 'üü¢' : '‚ö™';
                    const timestamp = new Date(project.last_action).toLocaleString();
                    option.textContent = `${statusIcon} ${project.task_id} (${project.action_count} actions)`;
                    option.title = `Last action: ${timestamp}`;

                    selector.appendChild(option);

                    // Set first (most recent) as default and load it
                    if (index === 0 && !getTaskIdFromUrl()) {
                        option.selected = true;
                        currentTaskId = project.task_id;
                        // Update URL with task_id and auto-load
                        const url = new URL(window.location);
                        url.searchParams.set('task_id', project.task_id);
                        window.history.replaceState({}, '', url);
                        // Auto-load the most recent task immediately
                        console.log(`[Auto-load] Loading most recent task: ${project.task_id}`);
                        fetchSequencerData();
                    }
                });

                // If URL has task_id, select it and load data
                const urlTaskId = getTaskIdFromUrl();
                if (urlTaskId) {
                    selector.value = urlTaskId;
                    currentTaskId = urlTaskId;
                    console.log(`[Auto-load] Loading task from URL: ${urlTaskId}`);
                    fetchSequencerData(); // Load the selected task
                }
            } else {
                // No projects found - this is OK, just show placeholder
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'No projects found';
                selector.appendChild(option);
            }
        } catch (error) {
            console.error('Error loading projects:', error);
            const selector = document.getElementById('project-selector');
            // FIX: Don't permanently show error - allow retrying by showing a temporary message
            selector.innerHTML = '<option value="">‚ö† Could not load projects (retrying...)</option>';

            // Retry after 5 seconds
            setTimeout(() => {
                console.log('[Retry] Attempting to reload projects...');
                loadProjects();
            }, 5000);
        }
    }

    // Handle project selection change
    function changeProject() {
        const selector = document.getElementById('project-selector');
        const selectedTaskId = selector.value;

        if (selectedTaskId) {
            // Update URL and reload sequencer data
            const url = new URL(window.location);
            url.searchParams.set('task_id', selectedTaskId);
            window.history.pushState({}, '', url);

            currentTaskId = selectedTaskId;
            fetchSequencerData();  // Reload with new task_id
        }
    }

    // Get task_id from URL query parameter
    function getTaskIdFromUrl() {
        const params = new URLSearchParams(window.location.search);
        return params.get('task_id') || params.get('source') === 'actions' ? params.get('task_id') : null;
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', async () => {
        console.log('Initializing sequencer view...');
        initializeSequencer();

        // Set persisted time range in dropdown
        const timeRangeSelect = document.getElementById('time-range');
        if (timeRangeSelect) {
            timeRangeSelect.value = timeRangeSeconds.toString();
        }

        // Load settings first
        const settings = getSettings();
        applyViewSettings(settings);

        // Restore arrow mode from localStorage (default to 'all')
        const savedArrowMode = settings.arrowMode || 'all';
        const arrowModeSelect = document.getElementById('arrow-display-mode');
        if (arrowModeSelect) {
            arrowModeSelect.value = savedArrowMode;
        }
        changeArrowMode(savedArrowMode);

        // Load projects list (this will auto-select and load the most recent)
        await loadProjects();

        // fetchSequencerData() will be called by loadProjects when it selects the first project

        // Update current time every second
        setInterval(updateCurrentTime, 1000);

        // Poll for active tasks every 3 seconds (fast updates when demo is running)
        setInterval(pollForActiveTasks, 3000);

        // Reload projects every 5 seconds to catch new ones
        setInterval(loadProjects, 5000);

        // Redraw canvas every second to update live duration counter for running tasks
        setInterval(() => {
            const hasRunningTasks = tasks.some(t =>
                !t.end_time && ['running', 'blocked', 'waiting'].includes(t.status)
            );
            if (hasRunningTasks) {
                drawSequencer(); // Redraw to update duration display
            }
        }, 1000);
    });
</script>
{% endblock %}
