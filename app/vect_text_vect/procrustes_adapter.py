"""Minimal Procrustes adapter for bridging embedding spaces.

The decoder expects vectors that live in the teacher embedding space.  When we
have vectors generated by an alternative encoder (e.g. sentence-transformers
GTR-T5 service) we can estimate an orthogonal mapping that aligns the alternate
space to the teacher space using paired examples.  This module keeps the helper
simple on purpose: load/save a mapping matrix and apply it on demand.
"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Iterable

import numpy as np

_ARRAY = np.ndarray


@dataclass
class ProcrustesAdapter:
    """Adapter that maps source vectors into the decoder space.

    The adapter stores the orthogonal Procrustes matrix as well as the feature
    statistics used during fitting so callers can reproduce the same
    normalisation pipeline at inference time.
    """

    transform: _ARRAY
    source_mean: _ARRAY
    source_std: _ARRAY
    target_mean: _ARRAY
    target_std: _ARRAY

    def __post_init__(self) -> None:
        self.transform = np.asarray(self.transform, dtype=np.float32)
        self.source_mean = np.asarray(self.source_mean, dtype=np.float32)
        self.source_std = np.asarray(self.source_std, dtype=np.float32)
        self.target_mean = np.asarray(self.target_mean, dtype=np.float32)
        self.target_std = np.asarray(self.target_std, dtype=np.float32)
        if self.transform.ndim != 2 or self.transform.shape[0] != self.transform.shape[1]:
            raise ValueError("transform must be a square matrix")

    @property
    def dimension(self) -> int:
        return int(self.transform.shape[0])

    def adapt(self, vectors: Iterable[_ARRAY], *, renormalise: bool = True) -> _ARRAY:
        """Map vectors from the source space into the decoder space."""
        arr = np.asarray(list(vectors), dtype=np.float32)
        if arr.ndim == 1:
            arr = arr.reshape(1, -1)
        if arr.shape[1] != self.dimension:
            raise ValueError(f"expected vectors with dimension {self.dimension}; received {arr.shape[1]}")
        normalised = (arr - self.source_mean) / np.clip(self.source_std, 1e-6, None)
        mapped = normalised @ self.transform
        if renormalise:
            mapped = mapped * self.target_std + self.target_mean
        return mapped

    def save(self, path: str | Path) -> None:
        path = Path(path)
        path.parent.mkdir(parents=True, exist_ok=True)
        np.savez_compressed(
            path,
            transform=self.transform,
            source_mean=self.source_mean,
            source_std=self.source_std,
            target_mean=self.target_mean,
            target_std=self.target_std,
        )

    @classmethod
    def load(cls, path: str | Path) -> "ProcrustesAdapter":
        data = np.load(Path(path), allow_pickle=False)
        return cls(
            transform=data["transform"],
            source_mean=data["source_mean"],
            source_std=data["source_std"],
            target_mean=data["target_mean"],
            target_std=data["target_std"],
        )

    @classmethod
    def from_examples(
        cls,
        source_vectors: Iterable[_ARRAY],
        target_vectors: Iterable[_ARRAY],
        *,
        epsilon: float = 1e-6,
    ) -> "ProcrustesAdapter":
        """Fit an orthogonal adapter using paired vectors."""
        src = np.asarray(list(source_vectors), dtype=np.float32)
        tgt = np.asarray(list(target_vectors), dtype=np.float32)
        if src.shape != tgt.shape:
            raise ValueError("source and target batches must share the same shape")
        if src.ndim != 2:
            raise ValueError("inputs must be two-dimensional [n_samples, dim]")
        src_mean = src.mean(axis=0, keepdims=True)
        tgt_mean = tgt.mean(axis=0, keepdims=True)
        src_std = src.std(axis=0, keepdims=True)
        tgt_std = tgt.std(axis=0, keepdims=True)
        src_std = np.where(src_std < epsilon, epsilon, src_std)
        tgt_std = np.where(tgt_std < epsilon, epsilon, tgt_std)
        src_norm = (src - src_mean) / src_std
        tgt_norm = (tgt - tgt_mean) / tgt_std
        cov = tgt_norm.T @ src_norm
        u, _, v_t = np.linalg.svd(cov, full_matrices=False)
        rotation = u @ v_t
        return cls(
            transform=rotation,
            source_mean=src_mean.squeeze(0),
            source_std=src_std.squeeze(0),
            target_mean=tgt_mean.squeeze(0),
            target_std=tgt_std.squeeze(0),
        )
