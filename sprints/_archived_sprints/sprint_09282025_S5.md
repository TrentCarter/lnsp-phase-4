[Consultant]
end-to-end (IDs → CPESH/TMD text → Postgres/Neo4j → 784-D vectors → FAISS → API/GraphRAG). Here’s a crisp wrap + what to run next so the system stays green at 10k and beyond.
Quick runbook (full 10k, repeatable)
0) Preflight (one time per shell)
export LNSP_GRAPHRAG_ENABLED=1
# keep FAISS stable on macOS arm64
export OMP_NUM_THREADS=1 VECLIB_MAXIMUM_THREADS=1 OPENBLAS_NUM_THREADS=1 MKL_NUM_THREADS=1 FAISS_NUM_THREADS=1
1) Ingest
# all 10k, or switch to your curated set
make ingest-all
# or a subset
./scripts/ingest_comprehensive.sh test_10_items.jsonl
2) Build / refresh FAISS
make build-faiss ARGS="--type ivf_flat --metric ip --nlist 512 --nprobe 16"
# heads-up: dynamic policy may auto-downshift nlist if vectors < 40×nlist
3) Rotate CPESH to Parquet + refresh SQLite index
make cpesh-rotate-nightly
4) Bring services up & verify
PORT=8094 make api
PORT=8094 make graph-smoke
PORT=8094 make lnsp-status
5) SLO snapshot (synthetic or real)
PORT=8094 make slo-grid           # uses eval/100q.jsonl if present, else synthetic
PORT=8094 make slo-snapshot
PORT=8094 make lnsp-status        # SLO table should now show queries/Hit@k/p50/p95
Go/No-Go checklist (what “healthy” looks like)
Postgres row count increments (you reported 10,006 ✅).
Neo4j constraints & FTS exist; /graph/health returns concepts>0, edges≥0.
FAISS index metadata shows sensible nlist (auto-downshift obeyed) and ntotal≈10k.
Dashboard: Segments table lists ≥1 Parquet segment; gating metrics present; SLO table present.
vec_upsert smoke passes; tests/test_neo4j.py idempotency test passes.
High-leverage follow-ups (when you’re ready)
Labelled eval set → real SLOs
Add doc_ids_gt to eval/100q.jsonl so Hit@1/3 become meaningful:
{"id":"q1","q":"What is photosynthesis?","lane":"L1_FACTOID","doc_ids_gt":["fw:doc:123"]}
Then re-run make slo-grid.
Nightly cron (rotation + index + SLO)
make cpesh-rotate-nightly
PORT=8094 make slo-grid SLO_NOTES="nightly"
Archive artifacts/metrics_slo.json with a date suffix.
Backups (local dev)
Postgres: pg_dump lnsp > backups/lnsp_$(date -u +%F).sql
Neo4j: neo4j-admin database dump neo4j --to-path backups/
Keep 7–14 days; check into your ops doc.
Tiny guardrails (prevent regressions)
Ensure LNSP_FAISS_INDEX points to the index you actually built before starting the API.
Keep the thread env pins (above) on macOS arm64 to avoid FAISS/OpenBLAS hiccups.
Expect nlist to be min(requested, vectors//40) for small corpora—warnings are normal when the guard kicks in.

[Consultant Progress 2025-03-07]
- Exported GraphRAG + BLAS env pins for session and attempted subset run using `test_comprehensive_ingest.jsonl` via `SKIP_NEO4J=1 AUTO_START=0 ./scripts/ingest_comprehensive.sh`.
- `pg_isready` confirms Postgres listener unavailable; runbook stops at service check even with auto-start disabled.
- Script tried `brew services start postgresql@14` but Homebrew is outside sandbox, so PostgreSQL remained down and ingestion aborted before vector generation.
- Unable to proceed to FAISS build / CPESH rotation / SLO checks until Postgres is reachable; recommend starting the local DB (brew services or docker-compose) and rerunning the ingestion step, then continue with Steps 2–5.
